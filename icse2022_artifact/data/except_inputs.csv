focal_method,test_prefix
"  public final boolean isLenient() {
    return lenient;
  }","  public void test39()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      String string0 = jsonReader0.nextString();
      assertEquals(""1"", string0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(string0);
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test41()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""FALSE"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      boolean boolean0 = jsonReader0.nextBoolean();
      assertFalse(boolean0);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test42()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""NULL"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      JsonToken jsonToken0 = jsonReader0.peek();
      assertEquals(JsonToken.NULL, jsonToken0);
      assertFalse(jsonReader0.isLenient());
      
      jsonReader0.nextNull();
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test45()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      double double0 = jsonReader0.nextDouble();
      assertEquals(1.0, double0, 0.01);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test49()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      long long0 = jsonReader0.nextLong();
      assertEquals(1L, long0);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test68()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.skipValue();
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test18()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(""java.lang#Float@0000000003"");
      assertTrue(jsonWriter1.getSerializeNulls());
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test20()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      JsonWriter jsonWriter1 = jsonWriter0.value(true);
      jsonWriter1.close();
      jsonWriter1.close();
      assertEquals(""true"", stringWriter0.toString());
      assertTrue(jsonWriter0.getSerializeNulls());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test59()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""464D"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.setLenient(true);
      assertTrue(jsonReader0.isLenient());
      
      long long0 = jsonReader0.nextLong();
      assertTrue(jsonReader0.isLenient());
      assertEquals(464L, long0);
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test76()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""464D"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.setLenient(true);
      assertTrue(jsonReader0.isLenient());
      
      int int0 = jsonReader0.nextInt();
      assertTrue(jsonReader0.isLenient());
      assertEquals(464, int0);
      
      jsonReader0.skipValue();
      assertTrue(jsonReader0.isLenient());
  }"
"  @Override public JsonWriter value(String value) throws IOException {
    if (value == null) {
      return nullValue();
    }
    put(new JsonPrimitive(value));
    return this;
  }","  public void test25()  throws Throwable  {
      JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();
      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);
      assertSame(jsonTreeWriter0, jsonWriter0);
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test25()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      jsonWriter0.value((Boolean) null);
      assertEquals(""null"", stringWriter0.toString());
      assertTrue(jsonWriter0.getSerializeNulls());
  }"
"    public int getIndex() {
        return index;
    }","  public void test48()  throws Throwable  {
      QName qName0 = new QName("""");
      VariablePointer variablePointer0 = new VariablePointer(qName0);
      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);
      BasicVariables basicVariables0 = new BasicVariables();
      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);
      int int0 = nodePointer0.compareTo(variablePointer1);
      assertEquals(1, int0);
      assertEquals(Integer.MIN_VALUE, variablePointer1.getIndex());
  }"
"    protected boolean equal(
        EvalContext context,
        Expression left,
        Expression right) 
    {
        Object l = left.compute(context);
        Object r = right.compute(context);

//        System.err.println(""COMPARING: "" +
//            (l == null ? ""null"" : l.getClass().getName()) + "" "" +
//            (r == null ? ""null"" : r.getClass().getName()));

        if (l instanceof InitialContext || l instanceof SelfContext) {
            l = ((EvalContext) l).getSingleNodePointer();
        }

        if (r instanceof InitialContext || r instanceof SelfContext) {
            r = ((EvalContext) r).getSingleNodePointer();
        }

        if (l instanceof Collection) {
            l = ((Collection) l).iterator();
        }

        if (r instanceof Collection) {
            r = ((Collection) r).iterator();
        }

        if ((l instanceof Iterator) && !(r instanceof Iterator)) {
            return contains((Iterator) l, r);
        }
        if (!(l instanceof Iterator) && (r instanceof Iterator)) {
            return contains((Iterator) r, l);
        }
        if (l instanceof Iterator && r instanceof Iterator) {
            return findMatch((Iterator) l, (Iterator) r);
        }
        return equal(l, r);
    }","  public void test02()  throws Throwable  {
      QName qName0 = new QName("""", """");
      VariableReference variableReference0 = new VariableReference(qName0);
      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);
      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);
      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);
      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);
      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);
      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);
      assertFalse(boolean0);
  }"
"    public boolean setPosition(int position) {
        if (position < getCurrentPosition()) {
            reset();
        }

        while (getCurrentPosition() < position) {
            if (!nextNode()) {
                return false;
            }
        }
        return true;
    }","  public void test4()  throws Throwable  {
      BasicNodeSet basicNodeSet0 = new BasicNodeSet();
      NodeSetContext nodeSetContext0 = new NodeSetContext((EvalContext) null, basicNodeSet0);
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);
      ChildContext childContext0 = new ChildContext(nodeSetContext0, nodeTypeTest0, true, true);
      AttributeContext attributeContext0 = new AttributeContext(childContext0, nodeTypeTest0);
      // Undeclared exception!
      try { 
        attributeContext0.setPosition(1);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.jxpath.ri.axes.AttributeContext"", e);
      }
  }"
"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }","  public void test0()  throws Throwable  {
      LinkedList<Chromosome> linkedList0 = new LinkedList<Chromosome>();
      ElitisticListPopulation elitisticListPopulation0 = null;
      try {
        elitisticListPopulation0 = new ElitisticListPopulation(linkedList0, 2144375856, 2144375856);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // elitism rate (2,144,375,856)
         //
         verifyException(""org.apache.commons.math3.genetics.ElitisticListPopulation"", e);
      }
  }"
"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }","  public void test2()  throws Throwable  {
      ElitisticListPopulation elitisticListPopulation0 = null;
      try {
        elitisticListPopulation0 = new ElitisticListPopulation(1905, (-146.889688));
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // elitism rate (-146.89)
         //
         verifyException(""org.apache.commons.math3.genetics.ElitisticListPopulation"", e);
      }
  }"
"    public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }","  public void test3()  throws Throwable  {
      OpenMapRealMatrix openMapRealMatrix0 = null;
      try {
        openMapRealMatrix0 = new OpenMapRealMatrix(2141034748, Integer.MAX_VALUE);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // 4,597,837,108,988,765,956 is larger than, or equal to, the maximum (2,147,483,647)
         //
         verifyException(""org.apache.commons.math.linear.OpenMapRealMatrix"", e);
      }
  }"
"    public static double[] bracket(UnivariateRealFunction function, 
            double initial, double lowerBound, double upperBound) 
    throws ConvergenceException, FunctionEvaluationException {
        return bracket( function, initial, lowerBound, upperBound,
            Integer.MAX_VALUE ) ;
    }","  public void test07()  throws Throwable  {
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 4037.4646;
      doubleArray0[1] = 283.42488442;
      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);
      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);
      assertArrayEquals(new double[] {0.0, 938.1475384}, doubleArray1, 0.01);
  }"
"    public static int lcm(int a, int b) {
        return Math.abs(mulAndCheck(a / gcd(a, b), b));
    }","  public void test002()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.lcm(1073741824, (-1216));
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: mul
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public static int subAndCheck(int x, int y) {
        long s = (long)x - (long)y;
        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
            throw new ArithmeticException(""overflow: subtract"");
        }
        return (int)s;
    }","  public void test116()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.subAndCheck(0L, (-9223372036854775553L));
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: subtract
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public static int gcd(final int p, final int q) {
        int u = p;
        int v = q;
        if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","  public void test061()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.gcd(Integer.MIN_VALUE, 0);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: gcd(-2,147,483,648, 0) is 2^31
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public static int gcd(final int p, final int q) {
        int u = p;
        int v = q;
        if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","  public void test062()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.gcd(0, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: gcd(0, -2,147,483,648) is 2^31
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public static int lcm(int a, int b) {
        if (a==0 || b==0){
            return 0;
        }
        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
        return lcm;
    }","  public void test081()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.lcm(4, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: lcm is 2^31
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test10()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn((-93.275), 0.0, 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      double[] doubleArray0 = new double[1];
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, true);
      dummyStepInterpolator0.storeTime((-3131.738));
      EventState eventState0 = new EventState(eventHandler0, 1028, 1028, 1028);
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, \uFFFD], Values: [-93.275, -93.275]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test14()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn((-1559.2660314847587), 0.0, 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      double[] doubleArray0 = new double[1];
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, false);
      EventState eventState0 = new EventState(eventHandler0, 2688.0509, 1142.904, (-1789569706));
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, \uFFFD], Values: [-1,559.266, -1,559.266]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test17()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn(1.0E-14, 1.0E-14, 1.0E-15, (-2137.64997125), 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      EventState eventState0 = new EventState(eventHandler0, (-929.39279781), (-929.39279781), (-243));
      double[] doubleArray0 = new double[3];
      eventState0.stepAccepted((-243.0), doubleArray0);
      eventState0.stepAccepted((-929.39279781), doubleArray0);
      eventState0.stepAccepted(0.0, doubleArray0);
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, true);
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, 0], Values: [-2,137.65, -2,137.65]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test00()  throws Throwable  {
      double[] doubleArray0 = new double[6];
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);
      assertEquals((-1689.2658367652516), double0, 0.01);
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test08()  throws Throwable  {
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 1.0E-14;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      brentSolver0.setFunctionValueAccuracy(1.0E-14);
      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);
      assertEquals((-859.8904), double0, 0.01);
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test09()  throws Throwable  {
      double[] doubleArray0 = new double[5];
      doubleArray0[2] = 1.0E-14;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      double double0 = brentSolver0.solve((-1.0), 1.0E-14);
      assertEquals(1.0E-14, double0, 0.01);
  }"
"    public void printWrapped(PrintWriter pw, int width, String text)
    {
        printWrapped(pw, width, 0, text);
    }","  public void test28()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""arg"");
      helpFormatter0.printWrapped((PrintWriter) mockPrintWriter0, 0, ""[ Options: [ short "");
  }"
"    public void printUsage(PrintWriter pw, int width, String app, Options options)
    {
        // initialise the string buffer
        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append("" "");

        // create a list for processed option groups
        final Collection processedGroups = new ArrayList();

        // temp variable
        Option option;

        List optList = new ArrayList(options.getOptions());
        Collections.sort(optList, getOptionComparator());
        // iterate over the options
        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            // get the next Option
            option = (Option) i.next();

            // check if the option is part of an OptionGroup
            OptionGroup group = options.getOptionGroup(option);

            // if the option is part of a group 
            if (group != null)
            {
                // and if the group has not already been processed
                if (!processedGroups.contains(group))
                {
                    // add the group to the processed list
                    processedGroups.add(group);


                    // add the usage clause
                    appendOptionGroup(buff, group);
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
                appendOption(buff, option, option.isRequired());
            }

            if (i.hasNext())
            {
                buff.append("" "");
            }
        }


        // call printWrapped
        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());
    }","  public void test32()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""opt contains illegal character value '"");
      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, ""opt contains illegal character value '"");
      assertEquals(74, helpFormatter0.defaultWidth);
  }"
"    public static Object createValue(final String str, final Object obj) throws ParseException
    {
        return createValue(str, (Class<?>) obj);
    }","  public void test10()  throws Throwable  {
      Class<Integer> class0 = Integer.class;
      try { 
        TypeHandler.createValue(""uo7{tEV1yjof"", class0);
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // Unable to handle the class: class java.lang.Integer
         //
         verifyException(""org.apache.commons.cli.TypeHandler"", e);
      }
  }"
"    static String stripLeadingHyphens(String str)
    {
        if (str.startsWith(""--""))
        {
            return str.substring(2, str.length());
        }
        else if (str.startsWith(""-""))
        {
            return str.substring(1, str.length());
        }

        return str;
    }","  public void test2()  throws Throwable  {
      String string0 = Util.stripLeadingHyphens((String) null);
      assertNull(string0);
  }"
"    public void printUsage(PrintWriter pw, int width, String app, 
                           Options options)
    {
        // initialise the string buffer
        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)
                                                                 .append("" "");

        // create a list for processed option groups
        final Collection processedGroups = new ArrayList();

        // temp variable
        Option option;

        List optList = new ArrayList(options.getOptions());
        Collections.sort(optList, new OptionComparator());
        // iterate over the options
        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            // get the next Option
            option = (Option) i.next();

            // check if the option is part of an OptionGroup
            OptionGroup group = options.getOptionGroup(option);

            // if the option is part of a group 
            if (group != null)
            {
                // and if the group has not already been processed
                if (!processedGroups.contains(group))
                {
                    // add the group to the processed list
                    processedGroups.add(group);


                    // add the usage clause
                    appendOptionGroup(buff, group);
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
                appendOption(buff, option, option.isRequired());
            }

            if (i.hasNext())
            {
                buff.append("" "");
            }
        }


        // call printWrapped
        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, 
                     buff.toString());
    }","  public void test27()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""-"");
      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 0, ""[ Options: [ sh6ort "");
  }"
"    public String getLongOptPrefix()
    {
        return defaultLongOptPrefix;
    }","  public void test24()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      Options options0 = new Options();
      helpFormatter0.printHelp(2, ""\n"", ""\n"", options0, ""6i4?l"");
      assertEquals(""--"", helpFormatter0.getLongOptPrefix());
  }"
"    public void printHelp(String cmdLineSyntax, Options options)
    {
        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);
    }","  public void test25()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      Options options0 = new Options();
      helpFormatter0.printHelp(2, ""-<e6=M|IgIm9wEy]?Rk"", "" "", options0, "" "");
      assertEquals(74, helpFormatter0.defaultWidth);
      assertEquals(3, helpFormatter0.defaultDescPad);
  }"
"    public void printHelp(String cmdLineSyntax, Options options)
    {
        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);
    }","  public void test29()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      assertEquals(3, helpFormatter0.defaultDescPad);
      assertEquals(3, HelpFormatter.DEFAULT_DESC_PAD);
      assertEquals(1, helpFormatter0.defaultLeftPad);
      assertEquals(74, HelpFormatter.DEFAULT_WIDTH);
      assertEquals(1, HelpFormatter.DEFAULT_LEFT_PAD);
      assertEquals(74, helpFormatter0.defaultWidth);
      assertEquals(""--"", helpFormatter0.getLongOptPrefix());
      assertEquals(""\n"", helpFormatter0.getNewLine());
      assertEquals(""arg"", helpFormatter0.getArgName());
      assertEquals(74, helpFormatter0.getWidth());
      assertEquals(1, helpFormatter0.getLeftPadding());
      assertEquals(""-"", helpFormatter0.getOptPrefix());
      assertEquals(""usage: "", helpFormatter0.getSyntaxPrefix());
      assertEquals(3, helpFormatter0.getDescPadding());
      assertNotNull(helpFormatter0);
      
      Options options0 = new Options();
      assertNotNull(options0);
      
      helpFormatter0.printHelp(1, ""\n"", ""arg"", options0, ""--"");
  }"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo

                if (!options.hasOption(opt))
                {
                    processNonOptionToken(token);
                }
                else
                {
                    
                    tokens.add(opt);
                    if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test1()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-PE---"";
      stringArray0[1] = """";
      stringArray0[2] = """";
      stringArray0[3] = ""A CloneNotSupportedExceptionwas thown: "";
      stringArray0[4] = ""--eA_{'~R[w=`"";
      // Undeclared exception!
      try { 
        posixParser0.flatten(options0, stringArray0, false);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }"
"    public CSVFormat withHeader(final String... header) {
        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,
                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);
    }","  public void test12()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.TDF;
      String[] stringArray0 = new String[4];
      // Undeclared exception!
      try { 
        cSVFormat0.DEFAULT.withHeader(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // The header contains a duplicate entry: 'null' in [null, null, null, null]
         //
         verifyException(""org.apache.commons.csv.CSVFormat"", e);
      }
  }"
"    public void print(final Object value) throws IOException {
        // null values are considered empty
        String strValue;
        if (value == null) {
            final String nullString = format.getNullString();
            strValue = nullString == null ? Constants.EMPTY : nullString;
        } else {
            strValue = value.toString();
        }
        this.print(value, strValue, 0, strValue.length());
    }","  public void test09()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.TDF;
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      Quote quote0 = Quote.NON_NUMERIC;
      CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
      PipedWriter pipedWriter0 = new PipedWriter();
      try { 
        cSVFormat2.print(pipedWriter0);
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
"    public long getRecordNumber() {
        return recordNumber;
    }","  public void test17()  throws Throwable  {
      HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
      Integer integer0 = new Integer(854);
      hashMap0.put((String) null, integer0);
      String[] stringArray0 = new String[0];
      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);
      cSVRecord0.toMap();
      assertEquals(854L, cSVRecord0.getRecordNumber());
  }"
"    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {
        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);
    }","  public void test5()  throws Throwable  {
      NameType nameType0 = NameType.SEPHARDIC;
      RuleType ruleType0 = RuleType.EXACT;
      PhoneticEngine phoneticEngine0 = null;
      try {
        phoneticEngine0 = new PhoneticEngine(nameType0, ruleType0, true);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class org.apache.commons.codec.language.bm.Lang
         //
         verifyException(""org.apache.commons.codec.language.bm.PhoneticEngine"", e);
      }
  }"
"    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
        if (bytes == null) {
            return null;
        }
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        for (int i = 0; i < bytes.length; i++) {
            final int b = bytes[i];
            if (b == ESCAPE_CHAR) {
                try {
                    // if the next octet is a CR we have found a soft line break
                    int u = Utils.digit16(bytes[++i]);
                    int l = Utils.digit16(bytes[++i]);
                    buffer.write((char) ((u << 4) + l));
                } catch (ArrayIndexOutOfBoundsException e) {
                    throw new DecoderException(""Invalid quoted-printable encoding"", e);
                }
            } else {
                // every other octet is appended except for CR & LF
                buffer.write(b);
            }
        }
        return buffer.toByteArray();
    }","  public void test09()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)61;
      byteArray0[1] = (byte)13;
      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);
      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0}, byteArray1);
  }"
"    public Base64() {
        this(false);
    }","  public void test00()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test01()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test02()  throws Throwable  {
      byte[] byteArray0 = new byte[17];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test03()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[12];
      // Undeclared exception!
      try { 
        Base64.encodeBase64Chunked(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test05()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test06()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test07()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((byte)1);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test08()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((byte) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test09()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test11()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[18];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test13()  throws Throwable  {
      byte[] byteArray0 = new byte[28];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test14()  throws Throwable  {
      byte[] byteArray0 = new byte[12];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte) (-1);
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)40;
      BigInteger bigInteger0 = new BigInteger(byteArray0);
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test17()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test18()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[10];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] decodeBase64(byte[] base64Data) {
        if (base64Data == null || base64Data.length == 0) {
            return base64Data;
        }
        Base64 b64 = new Base64();
        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.
        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }","  public void test20()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)83;
      // Undeclared exception!
      try { 
        Base64.decodeBase64(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test21()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, false, false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test24()  throws Throwable  {
      byte[] byteArray0 = new byte[18];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test25()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test28()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test35()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
        if (cs1 == null || cs2 == null) {
            return false;
        }
        if (cs1 instanceof String && cs2 instanceof String) {
            return cs1.equals(cs2);
        }
        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
    }","  public void test19()  throws Throwable  {
      char[] charArray0 = new char[0];
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) ""\uFFFD"");
      assertFalse(boolean0);
  }"
"    public String nodeName() {
        return ""#comment"";
    }","  public void test6()  throws Throwable  {
      Comment comment0 = new Comment(""')GQz^]r=Tof"");
      comment0.asXmlDeclaration();
      assertEquals(""#comment"", comment0.nodeName());
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test07()  throws Throwable  {
      Attribute attribute0 = new Attribute(""6xZW/$Zc"", ""6xZW/$Zc"");
      attribute0.setValue((String) null);
      Attribute attribute1 = attribute0.clone();
      boolean boolean0 = attribute0.equals(attribute1);
      assertEquals("""", attribute0.getValue());
      assertTrue(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test18()  throws Throwable  {
      Attribute attribute0 = Attribute.createFromEncoded(""9"", ""9"");
      attribute0.setValue((String) null);
      boolean boolean0 = attribute0.isBooleanAttribute();
      assertEquals("""", attribute0.getValue());
      assertTrue(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test24()  throws Throwable  {
      Attribute attribute0 = Attribute.createFromEncoded(""9"", ""9"");
      Attribute attribute1 = attribute0.clone();
      attribute1.setValue((String) null);
      boolean boolean0 = attribute1.equals(attribute0);
      assertEquals("""", attribute1.getValue());
      assertFalse(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test26()  throws Throwable  {
      Attribute attribute0 = new Attribute(""6xZW/$Zc"", ""6xZW/$Zc"");
      attribute0.setValue((String) null);
      attribute0.hashCode();
      assertEquals("""", attribute0.getValue());
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return accum.toString().trim();
    }","  public void test05()  throws Throwable  {
      Document document0 = new Document(""\""t(OU7Y?U9,'+GS9J@"");
      // Undeclared exception!
      try { 
        document0.html(""\""t(OU7Y?U9,'+GS9J@"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test08()  throws Throwable  {
      Element element0 = new Element(""org.jsoup.selectaluator$IsNthChild"");
      // Undeclared exception!
      try { 
        element0.html(""5;re4BBw,KJ+`!_K"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test74()  throws Throwable  {
      Element element0 = new Element(""textarea"");
      Element element1 = element0.prependElement(""textarea"");
      element1.val(""w.|^4]N&"");
      // Undeclared exception!
      try { 
        element0.html();
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    static String getCharsetFromContentType(String contentType) {
        if (contentType == null) return null;
        Matcher m = charsetPattern.matcher(contentType);
        if (m.find()) {
            String charset = m.group(1).trim();
                if (Charset.isSupported(charset)) return charset;
                charset = charset.toUpperCase(Locale.ENGLISH);
                if (Charset.isSupported(charset)) return charset;
                // if our advanced charset matching fails.... we just take the default
        }
        return null;
    }","  public void test13()  throws Throwable  {
      String string0 = DataUtil.getCharsetFromContentType(""charset="");
      assertNull(string0);
  }"
"    public String toString() {
        return outerHtml();
    }","  public void test08()  throws Throwable  {
      DataNode dataNode0 = DataNode.createFromEncoded(""Y3RuM2Iw}~sa=Np}"", """");
      String string0 = dataNode0.toString();
      assertEquals(""Y3RuM2Iw}~sa=Np}"", string0);
  }"
"    public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        final String out = (end >= 0) ? queue.substring(start, end) : """";
        return out;
    }
    
    /**
     * Unescaped a \ escaped string.
     * @param in backslash escaped string
     * @return unescaped string
     */
    public static String unescape(String in) {
        StringBuilder out = new StringBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == ESC) {
                if (last != 0 && last == ESC)
                    out.append(c);
            }
            else 
                out.append(c);
            last = c;
        }
        return out.toString();
    }

    /**
     * Pulls the next run of whitespace characters of the queue.
     * @return Whether consuming whitespace or not
     */
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            pos++;
            seen = true;
        }
        return seen;
    }

    /**
     * Retrieves the next run of word type (letter or digit) off the queue.
     * @return String of word characters from queue, or empty string if none.
     */
    public String consumeWord() {
        int start = pos;
        while (matchesWord())
            pos++;
        return queue.substring(start, pos);
    }
    
    /**
     * Consume an tag name off the queue (word or :, _, -)
     * 
     * @return tag name
     */
    public String consumeTagName() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))
            pos++;
        
        return queue.substring(start, pos);
    }
    
    /**
     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
     * 
     * @return tag name
     */
    public String consumeElementSelector() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(""*|"",""|"", ""_"", ""-"")))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
     @return identifier
     */
    public String consumeCssIdentifier() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))
            pos++;

        return queue.substring(start, pos);
    }

    /**
     Consume an attribute key off the queue (letter, digit, -, _, :"")
     @return attribute key
     */
    public String consumeAttributeKey() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume and return whatever is left on the queue.
     @return remained of queue.
     */
    public String remainder() {
        final String remainder = queue.substring(pos, queue.length());
        pos = queue.length();
        return remainder;
    }
    
    @Override
    public String toString() {
        return queue.substring(pos);
    }
}
","  public void test05()  throws Throwable  {
      TokenQueue tokenQueue0 = new TokenQueue(""'N7N;gmEL"");
      // Undeclared exception!
      try { 
        tokenQueue0.chompBalanced('\'', '\'');
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Did not find balanced maker at N7N;gmEL
         //
         verifyException(""org.jsoup.helper.Validate"", e);
      }
  }"
"    public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        final String out = (end >= 0) ? queue.substring(start, end) : """";
        return out;
    }
    
    /**
     * Unescaped a \ escaped string.
     * @param in backslash escaped string
     * @return unescaped string
     */
    public static String unescape(String in) {
        StringBuilder out = new StringBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == ESC) {
                if (last != 0 && last == ESC)
                    out.append(c);
            }
            else 
                out.append(c);
            last = c;
        }
        return out.toString();
    }

    /**
     * Pulls the next run of whitespace characters of the queue.
     * @return Whether consuming whitespace or not
     */
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            pos++;
            seen = true;
        }
        return seen;
    }

    /**
     * Retrieves the next run of word type (letter or digit) off the queue.
     * @return String of word characters from queue, or empty string if none.
     */
    public String consumeWord() {
        int start = pos;
        while (matchesWord())
            pos++;
        return queue.substring(start, pos);
    }
    
    /**
     * Consume an tag name off the queue (word or :, _, -)
     * 
     * @return tag name
     */
    public String consumeTagName() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))
            pos++;
        
        return queue.substring(start, pos);
    }
    
    /**
     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
     * 
     * @return tag name
     */
    public String consumeElementSelector() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(""*|"",""|"", ""_"", ""-"")))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
     @return identifier
     */
    public String consumeCssIdentifier() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))
            pos++;

        return queue.substring(start, pos);
    }

    /**
     Consume an attribute key off the queue (letter, digit, -, _, :"")
     @return attribute key
     */
    public String consumeAttributeKey() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume and return whatever is left on the queue.
     @return remained of queue.
     */
    public String remainder() {
        final String remainder = queue.substring(pos, queue.length());
        pos = queue.length();
        return remainder;
    }
    
    @Override
    public String toString() {
        return queue.substring(pos);
    }
}
","  public void test24()  throws Throwable  {
      TokenQueue tokenQueue0 = new TokenQueue(""heCIIhcb$o"");
      assertFalse(tokenQueue0.isEmpty());
      assertTrue(tokenQueue0.matchesWord());
      assertFalse(tokenQueue0.matchesStartTag());
      assertEquals(""heCIIhcb$o"", tokenQueue0.toString());
      assertEquals('h', tokenQueue0.peek());
      assertNotNull(tokenQueue0);
      
      // Undeclared exception!
      try { 
        tokenQueue0.chompBalanced('h', 'h');
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Did not find balanced maker at eCIIhcb$o
         //
         verifyException(""org.jsoup.helper.Validate"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test37()  throws Throwable  {
      Document document0 = new Document(""br"");
      document0.appendChild(document0);
      // Undeclared exception!
      try { 
        document0.html(""br"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum); 
        return accum.toString().trim();
    }","  public void test06()  throws Throwable  {
      Document document0 = new Document(""d|kN/6:H"");
      // Undeclared exception!
      try { 
        document0.html(""JKjy$]SO>hwwo?|"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    boolean containsIgnoreCase(String seq) {
        // used to check presence of </title>, </style>. only finds consistent case.
        String loScan = seq.toLowerCase(Locale.ENGLISH);
        String hiScan = seq.toUpperCase(Locale.ENGLISH);
        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);
    }","  public void test12()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""8Kr':%(6-\""p@8&Z_$8"");
      boolean boolean0 = characterReader0.containsIgnoreCase(""8Kr':%(6-\""p@8&Z_$8"");
      assertFalse(boolean0);
  }"
"    public Document clean(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
            copySafeNodes(dirtyDocument.body(), clean.body());

        return clean;
    }","  public void test0()  throws Throwable  {
      Whitelist whitelist0 = Whitelist.basicWithImages();
      Cleaner cleaner0 = new Cleaner(whitelist0);
      Document document0 = new Document("")}IYN&vF+R/bSRCs bc"");
      Document document1 = cleaner0.clean(document0);
      assertNotSame(document1, document0);
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test07()  throws Throwable  {
      Document document0 = new Document(""rn<y!,}g<6vpwvpjc`"");
      // Undeclared exception!
      try { 
        document0.html(""aSBR%LKA-{"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String toString() {
        return input.substring(pos);
    }","  public void test14()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""J"");
      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(""J"");
      assertTrue(boolean0);
      
      characterReader0.consumeTo('J');
      assertEquals("""", characterReader0.toString());
  }"
"    public static long parseOctalOrBinary(final byte[] buffer, final int offset,
                                          final int length) {

        if ((buffer[offset] & 0x80) == 0) {
            return parseOctal(buffer, offset, length);
        }
        final boolean negative = buffer[offset] == (byte) 0xff;
        if (length < 9) {
            return parseBinaryLong(buffer, offset, length, negative);
        }
        return parseBinaryBigInteger(buffer, offset, length, negative);
    }","  public void test00()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);
      assertEquals(2, int0);
      
      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);
      assertArrayEquals(new byte[] {(byte)48, (byte)32, (byte)0, (byte)0}, byteArray0);
      assertEquals(0L, long0);
  }"
"    public String getEncoding() {
        return encoding;
    }","  public void test23()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""bad CRC checksum for entry "");
      assertNotNull(mockFile0);
      
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);
      assertTrue(mockFile0.exists());
      assertEquals(""bad CRC checksum for entry "", mockFile0.toString());
      assertFalse(mockFile0.isDirectory());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertNull(mockFile0.getParent());
      assertFalse(mockFile0.isHidden());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertTrue(mockFile0.canExecute());
      assertEquals(""bad CRC checksum for entry "", mockFile0.getName());
      assertTrue(mockFile0.canRead());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.isFile());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertEquals(0L, mockFile0.length());
      assertFalse(mockFile0.isAbsolute());
      assertTrue(zipArchiveOutputStream0.isSeekable());
      assertEquals(""UTF8"", zipArchiveOutputStream0.getEncoding());
      assertNotNull(zipArchiveOutputStream0);
      assertEquals(2048, ZipArchiveOutputStream.EFS_FLAG);
      assertEquals(0, ZipArchiveOutputStream.STORED);
      assertEquals((-1), ZipArchiveOutputStream.DEFAULT_COMPRESSION);
      assertEquals(8, ZipArchiveOutputStream.DEFLATED);
      
      zipArchiveOutputStream0.close();
      assertTrue(mockFile0.exists());
      assertEquals(""bad CRC checksum for entry "", mockFile0.toString());
      assertFalse(mockFile0.isDirectory());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertNull(mockFile0.getParent());
      assertFalse(mockFile0.isHidden());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertTrue(mockFile0.canExecute());
      assertEquals(""bad CRC checksum for entry "", mockFile0.getName());
      assertTrue(mockFile0.canRead());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.isFile());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertEquals(0L, mockFile0.length());
      assertFalse(mockFile0.isAbsolute());
      assertTrue(zipArchiveOutputStream0.isSeekable());
      assertEquals(""UTF8"", zipArchiveOutputStream0.getEncoding());
      assertEquals(2048, ZipArchiveOutputStream.EFS_FLAG);
      assertEquals(0, ZipArchiveOutputStream.STORED);
      assertEquals((-1), ZipArchiveOutputStream.DEFAULT_COMPRESSION);
      assertEquals(8, ZipArchiveOutputStream.DEFLATED);
  }"
"    public void finish() throws IOException {
        ensureOpen();

        if (this.finished) {
            return;
        }
        if (this.entry != null) {
            throw new IOException(""This archives contains unclosed entries."");
        }
        this.entry = new CpioArchiveEntry(this.entryFormat);
        this.entry.setName(CPIO_TRAILER);
        this.entry.setNumberOfLinks(1);
        writeHeader(this.entry);
        closeArchiveEntry();
    }","  public void test10()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      assertNotNull(byteArrayOutputStream0);
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      assertNotNull(cpioArchiveOutputStream0);
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      cpioArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      try { 
        cpioArchiveOutputStream0.finish();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
      }
  }"
"    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)
            throws IOException {
        ChangeSetResults results = new ChangeSetResults();
        
        Set workingSet = new LinkedHashSet(changes);
        
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }

        ArchiveEntry entry = null;
        while ((entry = in.getNextEntry()) != null) {
            boolean copy = true;

            for (Iterator it = workingSet.iterator(); it.hasNext();) {
                Change change = (Change) it.next();

                final int type = change.type();
                final String name = entry.getName();
                if (type == Change.TYPE_DELETE && name != null) {
                    if (name.equals(change.targetFile())) {
                        copy = false;
                        it.remove();
                        results.deleted(name);
                        break;
                    }
                } else if(type == Change.TYPE_DELETE_DIR && name != null) {
                    if (name.startsWith(change.targetFile() + ""/"")) {
                        copy = false;
                        results.deleted(name);
                        break;
                    }
                }
            }

            if (copy) {
                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                    copyStream(in, out, entry);
                    results.addedFromStream(entry.getName());
                }
            }
        }
        
        // Adds files which hasn't been added from the original and do not have replace mode on
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && 
                !change.isReplaceMode() && 
                !results.hasBeenAdded(change.getEntry().getName())) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }
        return results;
    }","  public void test0()  throws Throwable  {
      ChangeSet changeSet0 = new ChangeSet();
      JarArchiveOutputStream jarArchiveOutputStream0 = new JarArchiveOutputStream((OutputStream) null);
      byte[] byteArray0 = new byte[9];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, 190);
      changeSet0.deleteDir("""");
      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, ""m"", false);
      ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
      // Undeclared exception!
      try { 
        changeSetPerformer0.perform(zipArchiveInputStream0, jarArchiveOutputStream0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream"", e);
      }
  }"
"    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {



        this.checksum = checksum;
        this.in = in;
    }","  public void test2()  throws Throwable  {
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;
      try {
        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream((Checksum) null, mockFileInputStream0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // Parameter checksum must not be null
         //
         verifyException(""org.apache.commons.compress.utils.ChecksumCalculatingInputStream"", e);
      }
  }"
"    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {



        this.checksum = checksum;
        this.in = in;
    }","  public void test3()  throws Throwable  {
      Adler32 adler32_0 = new Adler32();
      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;
      try {
        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream(adler32_0, (InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // Parameter in must not be null
         //
         verifyException(""org.apache.commons.compress.utils.ChecksumCalculatingInputStream"", e);
      }
  }"
    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); },"  public void test27()  throws Throwable  {
      X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
      MockDate mockDate0 = new MockDate((-2), (byte)2, (byte)2);
      // Undeclared exception!
      try { 
        x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // X5455 timestamps must fit in a signed 32 bit integer: -2266876800
         //
         verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
      }
  }"
"    public ArchiveOutputStream createArchiveOutputStream(
            final String archiverName, final OutputStream out)
            throws ArchiveException {
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        if (out == null) {
            throw new IllegalArgumentException(""OutputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveOutputStream(out);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
            if (entryEncoding != null) {
                zip.setEncoding(entryEncoding);
            }
            return zip;
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new TarArchiveOutputStream(out, entryEncoding);
            } else {
                return new TarArchiveOutputStream(out);
            }
        }
        if (JAR.equalsIgnoreCase(archiverName)) {
                return new JarArchiveOutputStream(out);
        }
        if (CPIO.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new CpioArchiveOutputStream(out, entryEncoding);
            } else {
                return new CpioArchiveOutputStream(out);
            }
        }
        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }","  public void test28()  throws Throwable  {
      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory("""");
      MockPrintStream mockPrintStream0 = new MockPrintStream(""arj"");
      // Undeclared exception!
      try { 
        archiveStreamFactory0.createArchiveOutputStream(""jar"", mockPrintStream0);
        fail(""Expecting exception: IllegalCharsetNameException"");
      
      } catch(IllegalCharsetNameException e) {
         //
         // 
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Trim all trailing NULs and spaces.
        // The ustar and POSIX tar specs require a trailing NUL or
        // space but some implementations use the extra digit for big
        // sizes/uids/gids ...
        byte trailer = buffer[end - 1];
        if (trailer == 0 || trailer == ' '){
            end--;
        } else {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, end-1, trailer));
        }
        trailer = buffer[end - 1];
        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
            end--;
            trailer = buffer[end - 1];
        }

        for ( ;start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte)32;
      byteArray0[3] = (byte)32;
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, 2, 2);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid byte 32 at offset 2 in '  ' len=2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public SevenZFile(final File filename, final byte[] password) throws IOException {
        boolean succeeded = false;
        this.file = new RandomAccessFile(filename, ""r"");
        this.fileName = filename.getAbsolutePath();
        try {
            archive = readHeaders(password);
            if (password != null) {
                this.password = new byte[password.length];
                System.arraycopy(password, 0, this.password, 0, password.length);
            } else {
                this.password = null;
            }
            succeeded = true;
        } finally {
            if (!succeeded) {
                this.file.close();
            }
        }
    }","  public void test0()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""}$LSF"");
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""}$LSF"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ""}$LSF"");
      SevenZFile sevenZFile0 = null;
      try {
        sevenZFile0 = new SevenZFile(mockFile0);
        fail(""Expecting exception: EOFException"");
      
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.RandomAccessFile"", e);
      }
  }"
"    public static boolean matches(final byte[] signature, final int length) {
        if (length < sevenZSignature.length) {
            return false;
        }

        for (int i = 0; i < sevenZSignature.length; i++) {
            if (signature[i] != sevenZSignature[i]) {
                return false;
            }
        }
        return true;
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)55;
      boolean boolean0 = SevenZFile.matches(byteArray0, (byte)55);
      assertFalse(boolean0);
  }"
"    public ArchiveInputStream createArchiveInputStream(
            final String archiverName, final InputStream in)
            throws ArchiveException {
        
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        
        if (in == null) {
            throw new IllegalArgumentException(""InputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveInputStream(in);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            return new ZipArchiveInputStream(in);
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            return new TarArchiveInputStream(in);
        }
        if (JAR.equalsIgnoreCase(archiverName)) {
            return new JarArchiveInputStream(in);
        }
        if (CPIO.equalsIgnoreCase(archiverName)) {
            return new CpioArchiveInputStream(in);
        }
        if (DUMP.equalsIgnoreCase(archiverName)) {
            return new DumpArchiveInputStream(in);
        }
        
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[179];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory();
      try { 
        archiveStreamFactory0.createArchiveInputStream((InputStream) byteArrayInputStream0);
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // No Archiver found for the stream signature
         //
         verifyException(""org.apache.commons.compress.archivers.ArchiveStreamFactory"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        int     start = offset;

        for (int i = start; i < end; i++){
            final byte currentByte = buffer[i];
            if (currentByte == 0) {
                break;
            }

        // Skip leading spaces
            if (currentByte == (byte) ' ' || currentByte == '0') {
                if (stillPadding) {
                   continue;
            }
                if (currentByte == (byte) ' ') {
                break;
                }
            }

        // Must have trailing NUL or space
        // May have additional NUL or space

            stillPadding = false;
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test02()  throws Throwable  {
      byte[] byteArray0 = new byte[25];
      byteArray0[4] = (byte)54;
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, (byte)3, 2);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid byte 54 at offset 1 in '{NUL}6' len=2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        int     start = offset;

        for (int i = start; i < end; i++){
            final byte currentByte = buffer[i];
            if (currentByte == 0) {
                break;
            }

        // Skip leading spaces
            if (currentByte == (byte) ' ' || currentByte == '0') {
                if (stillPadding) {
                   continue;
            }
                if (currentByte == (byte) ' ') {
                break;
                }
            }

        // Must have trailing NUL or space
        // May have additional NUL or space

            stillPadding = false;
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, (byte)3, (byte)0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Length 0 must be at least 2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public ZipArchiveEntry getNextZipEntry() throws IOException {
        boolean firstEntry = true;
        if (closed || hitCentralDirectory) {
            return null;
        }
        if (current != null) {
            closeEntry();
            firstEntry = false;
        }

        try {
            if (firstEntry) {
                // split archives have a special signature before the
                // first local file header - look for it and fail with
                // the appropriate error message if this is a split
                // archive.
                readFirstLocalFileHeader(LFH_BUF);
            } else {
                readFully(LFH_BUF);
            }
        } catch (final EOFException e) {
            return null;
        }

        final ZipLong sig = new ZipLong(LFH_BUF);
        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
            hitCentralDirectory = true;
            skipRemainderOfArchive();
        }
        if (!sig.equals(ZipLong.LFH_SIG)) {
            return null;
        }

        int off = WORD;
        current = new CurrentEntry();

        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;
        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);

        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
        current.hasDataDescriptor = gpFlag.usesDataDescriptor();
        current.entry.setGeneralPurposeBit(gpFlag);

        off += SHORT;

        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
        off += SHORT;

        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
        current.entry.setTime(time);
        off += WORD;

        ZipLong size = null, cSize = null;
        if (!current.hasDataDescriptor) {
            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
            off += WORD;

            cSize = new ZipLong(LFH_BUF, off);
            off += WORD;

            size = new ZipLong(LFH_BUF, off);
            off += WORD;
        } else {
            off += 3 * WORD;
        }

        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);

        off += SHORT;

        final int extraLen = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;

        final byte[] fileName = new byte[fileNameLen];
        readFully(fileName);
        current.entry.setName(entryEncoding.decode(fileName), fileName);

        final byte[] extraData = new byte[extraLen];
        readFully(extraData);
        current.entry.setExtra(extraData);

        if (!hasUTF8Flag && useUnicodeExtraFields) {
            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
        }

        processZip64Extra(size, cSize);

        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
                current.in = new ExplodingInputStream(
                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),
                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),
                        new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            }
        }
        
        entriesRead++;
        return current.entry;
    }","  public void test03()  throws Throwable  {
      byte[] byteArray0 = new byte[40];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
      try { 
        zipArchiveInputStream0.getNextZipEntry();
        fail(""Expecting exception: ZipException"");
      
      } catch(ZipException e) {
         //
         // Unexpected record signature: 0X0
         //
         verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
      }
  }"
"    public ArArchiveEntry getNextArEntry() throws IOException {
                    // hit EOF before previous entry was complete
                    // TODO: throw an exception instead?

        if (offset == 0) {
            final byte[] expected = ArArchiveEntry.HEADER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid header "" + new String(realized));
                }
            }
        }

                // hit eof

        if (input.available() == 0) {
            return null;
        }

        if (offset % 2 != 0) {
            read();
        }
        final byte[] name = new byte[16];
        final byte[] lastmodified = new byte[12];
        final byte[] userid = new byte[6];
        final byte[] groupid = new byte[6];
        final byte[] filemode = new byte[8];
        final byte[] length = new byte[10];

        read(name);
        read(lastmodified);
        read(userid);
        read(groupid);
        read(filemode);
        read(length);

        {
            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read entry header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid entry header. not read the content?"");
                }
            }
        }

        return new ArArchiveEntry(new String(name).trim(),
                                          Long.parseLong(new String(length)
                                                         .trim()));
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);
      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);
      arArchiveInputStream0.read();
      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();
      assertNull(arArchiveEntry0);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test19()  throws Throwable  {
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);
      assertNotSame(zip64ExtendedInformationExtraField0, zip64ExtendedInformationExtraField1);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test23()  throws Throwable  {
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 22);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, false, true, false);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test24()  throws Throwable  {
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 16);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, false, true);
  }"
"    public static long parseOctalOrBinary(final byte[] buffer, final int offset,
                                          final int length) {

        if ((buffer[offset] & 0x80) == 0) {
            return parseOctal(buffer, offset, length);
        }
        final boolean negative = buffer[offset] == (byte) 0xff;
        if (length < 9) {
            return parseBinaryLong(buffer, offset, length, negative);
        }
        return parseBinaryBigInteger(buffer, offset, length, negative);
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[36];
      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);
      assertEquals(12, int0);
      
      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);
      assertEquals(6L, long0);
  }"
"    public void writeEmbeddedObject(Object object) throws IOException {
        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases
        throw new JsonGenerationException(""No native support for writing embedded objects"",
                this);
    }","  public void test45()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);
      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
  }"
    public boolean isResourceManaged() { return _managedResource; },"  public void test22()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      Object object0 = new Object();
      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
      iOContext0.allocWriteEncodingBuffer();
      byte[] byteArray0 = iOContext0.allocReadIOBuffer();
      iOContext0.releaseWriteEncodingBuffer(byteArray0);
      assertTrue(iOContext0.isResourceManaged());
  }"
"    public Boolean nextBooleanValue()
        throws IOException, JsonParseException
    {
        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'
            _nameCopied = false;
            JsonToken t = _nextToken;
            _nextToken = null;
            _currToken = t;
            if (t == JsonToken.VALUE_TRUE) {
                return Boolean.TRUE;
            }
            if (t == JsonToken.VALUE_FALSE) {
                return Boolean.FALSE;
            }
            if (t == JsonToken.START_ARRAY) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            } else if (t == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            return null;
        }
        switch (nextToken()) {
        case VALUE_TRUE:
            return Boolean.TRUE;
        case VALUE_FALSE:
            return Boolean.FALSE;
        default:
        	return null;
        }
    }","  public void test26()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(bufferRecycler0);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, ""1IoL_.}7~~\""HL_r*"", false);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(iOContext0);
      assertNull(iOContext0.getEncoding());
      assertFalse(iOContext0.isResourceManaged());
      
      StringReader stringReader0 = new StringReader(""0JMmtsG8ryBAGj-U!"");
      assertNotNull(stringReader0);
      
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(charsToNameCanonicalizer0);
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      
      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(readerBasedJsonParser0);
      assertNull(iOContext0.getEncoding());
      assertFalse(iOContext0.isResourceManaged());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertNull(readerBasedJsonParser0.getCurrentName());
      assertNull(readerBasedJsonParser0.getLastClearedToken());
      assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
      assertFalse(readerBasedJsonParser0.canReadTypeId());
      assertFalse(readerBasedJsonParser0.canReadObjectId());
      assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
      assertFalse(readerBasedJsonParser0.requiresCustomCodec());
      assertFalse(readerBasedJsonParser0.isClosed());
      assertFalse(readerBasedJsonParser0.hasTextCharacters());
      assertFalse(readerBasedJsonParser0.hasCurrentToken());
      assertEquals(2000, readerBasedJsonParser0.getFeatureMask());
      assertNull(readerBasedJsonParser0.getCurrentToken());
      assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
      
      try { 
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Unexpected character ('J' (code 74)): Expected space separating root-level values
         //  at [Source: java.lang.String@0000000014; line: 1, column: 3]
         //
         verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
      }
  }"
"    public JsonToken nextToken()
        throws IOException, JsonParseException
    {
        _numTypesValid = NR_UNKNOWN;

        /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
        if (_currToken == JsonToken.FIELD_NAME) {
            return _nextAfterName();
        }
        if (_tokenIncomplete) {
            _skipString(); // only strings can be partial
        }
        int i = _skipWSOrEnd();
        if (i < 0) { // end-of-input
            /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
            close();
            return (_currToken = null);
        }

        /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
        _tokenInputRow = _currInputRow;
        _tokenInputCol = _inputPtr - _currInputRowStart - 1;

        // finally: clear any data retained so far
        _binaryValue = null;

        // Closing scope?
        if (i == INT_RBRACKET) {
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_ARRAY);
        }","  public void test27()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(bufferRecycler0);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(iOContext0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      
      StringReader stringReader0 = new StringReader(""1IoL_.}7~~\""HL_r*"");
      assertNotNull(stringReader0);
      
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(charsToNameCanonicalizer0);
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1722), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(readerBasedJsonParser0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertNull(readerBasedJsonParser0.getCurrentName());
      assertFalse(readerBasedJsonParser0.isClosed());
      assertNull(readerBasedJsonParser0.getCurrentToken());
      assertNull(readerBasedJsonParser0.getLastClearedToken());
      assertFalse(readerBasedJsonParser0.canReadTypeId());
      assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
      assertEquals((-1722), readerBasedJsonParser0.getFeatureMask());
      assertFalse(readerBasedJsonParser0.requiresCustomCodec());
      assertFalse(readerBasedJsonParser0.canReadObjectId());
      assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
      assertFalse(readerBasedJsonParser0.hasCurrentToken());
      assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
      assertFalse(readerBasedJsonParser0.hasTextCharacters());
      
      try { 
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Unexpected character ('I' (code 73)): Expected space separating root-level values
         //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 3]
         //
         verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test29()  throws Throwable  {
      TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
      textBuffer0.contentsAsArray();
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test30()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.getCurrentSegment();
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test31()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      BufferRecycler.CharBufferType bufferRecycler_CharBufferType0 = BufferRecycler.CharBufferType.TOKEN_BUFFER;
      char[] charArray0 = bufferRecycler0.allocCharBuffer(bufferRecycler_CharBufferType0);
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithShared(charArray0, 1, 1);
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test32()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.getCurrentSegment();
      textBuffer0.setCurrentLength(2000);
      textBuffer0.append('7');
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test44()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithShared((char[]) null, 2000, 2000);
      // Undeclared exception!
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.Arrays"", e);
      }
  }"
"    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException
    {
            return new BigDecimal(numStr);
    }","  public void test00()  throws Throwable  {
      char[] charArray0 = new char[3];
      try { 
        NumberInput.parseBigDecimal(charArray0);
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\u0000\u0000\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public void writeNumber(short s) throws IOException
    {
        _verifyValueWrite(WRITE_NUMBER);
        // up to 5 digits and possible minus sign
        if ((_outputTail + 6) >= _outputEnd) {
            _flushBuffer();
        }
        if (_cfgNumbersAsStrings) {
            _writeQuotedShort(s);
            return;
        }
        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
    }","  public void test69()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertNotNull(bufferRecycler0);
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
      assertNotNull(iOContext0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      
      MockFile mockFile0 = new MockFile(""i]mir@"");
      assertNotNull(mockFile0);
      
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      assertNotNull(mockFileOutputStream0);
      
      byte[] byteArray0 = new byte[1];
      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 154, true);
      assertNotNull(uTF8JsonGenerator0);
      assertArrayEquals(new byte[] {(byte)0}, byteArray0);
      assertEquals(1, byteArray0.length);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertFalse(mockFile0.isDirectory());
      assertNull(mockFile0.getParent());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertFalse(mockFile0.isAbsolute());
      assertEquals(""i]mir@"", mockFile0.getName());
      assertEquals(0L, mockFile0.length());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertTrue(mockFile0.canExecute());
      assertTrue(mockFile0.isFile());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.canRead());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertFalse(mockFile0.isHidden());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertTrue(mockFile0.exists());
      assertEquals(""i]mir@"", mockFile0.toString());
      assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
      assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
      assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
      assertFalse(uTF8JsonGenerator0.canWriteObjectId());
      assertEquals(154, uTF8JsonGenerator0.getOutputBuffered());
      assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
      assertFalse(uTF8JsonGenerator0.canWriteTypeId());
      assertTrue(uTF8JsonGenerator0.canOmitFields());
      assertFalse(uTF8JsonGenerator0.isClosed());
      assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      assertEquals(56319, GeneratorBase.SURR1_LAST);
      assertEquals(56320, GeneratorBase.SURR2_FIRST);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
      assertEquals(55296, GeneratorBase.SURR1_FIRST);
      
      uTF8JsonGenerator0.writeString((char[]) null, 2, 0);
      assertArrayEquals(new byte[] {(byte)34}, byteArray0);
      assertEquals(1, byteArray0.length);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertFalse(mockFile0.isDirectory());
      assertEquals(2L, mockFile0.length());
      assertNull(mockFile0.getParent());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertFalse(mockFile0.isAbsolute());
      assertEquals(""i]mir@"", mockFile0.getName());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertTrue(mockFile0.canExecute());
      assertTrue(mockFile0.isFile());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.canRead());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertFalse(mockFile0.isHidden());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertTrue(mockFile0.exists());
      assertEquals(""i]mir@"", mockFile0.toString());
      assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
      assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
      assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
      assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
      assertFalse(uTF8JsonGenerator0.canWriteObjectId());
      assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
      assertFalse(uTF8JsonGenerator0.canWriteTypeId());
      assertTrue(uTF8JsonGenerator0.canOmitFields());
      assertFalse(uTF8JsonGenerator0.isClosed());
      assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      assertEquals(56319, GeneratorBase.SURR1_LAST);
      assertEquals(56320, GeneratorBase.SURR2_FIRST);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
      assertEquals(55296, GeneratorBase.SURR1_FIRST);
      
      // Undeclared exception!
      try { 
        uTF8JsonGenerator0.writeNumber((-1.0F));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
      }
  }"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test12()  throws Throwable  {
      StdDateFormat stdDateFormat0 = new StdDateFormat();
      stdDateFormat0.instance.setLenient(true);
      assertTrue(stdDateFormat0.isLenient());
  }"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test13()  throws Throwable  {
      StdDateFormat stdDateFormat0 = new StdDateFormat();
      stdDateFormat0.setLenient(false);
      assertFalse(stdDateFormat0.isLenient());
  }"
"    public long getLongValue() throws IOException {
        final NumericNode node = (NumericNode) currentNumericNode();
        return node.longValue();
    }","  public void test34()  throws Throwable  {
      LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));
      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);
      // Undeclared exception!
      try { 
        treeTraversingParser0.getLongValue();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.fasterxml.jackson.databind.node.TreeTraversingParser"", e);
      }
  }"
"    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException
    {
        if (_value == null) {
            ctxt.defaultSerializeNull(gen);
        } else if (_value instanceof JsonSerializable) {
            ((JsonSerializable) _value).serialize(gen, ctxt);
        } else {
            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;
            //    this to preserve contextual information
            gen.writeObject(_value);
        }
    }","  public void test18()  throws Throwable  {
      POJONode pOJONode0 = new POJONode(""b4axvGC0V"");
      JsonFactory jsonFactory0 = new JsonFactory();
      StringWriter stringWriter0 = new StringWriter();
      JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((Writer) stringWriter0);
      // Undeclared exception!
      try { 
        pOJONode0.serialize(jsonGenerator0, (SerializerProvider) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.fasterxml.jackson.databind.node.POJONode"", e);
      }
  }"
"    public int capacity() {
        return buffer.length;
    }","  public void test015()  throws Throwable  {
      StrBuilder strBuilder0 = new StrBuilder((String) null);
      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');
      assertEquals(45, strBuilder0.capacity());
  }"
"    public int length() {
        return size;
    }","  public void test132()  throws Throwable  {
      StrBuilder strBuilder0 = new StrBuilder(574);
      assertNotNull(strBuilder0);
      assertEquals(0, strBuilder0.length());
      assertTrue(strBuilder0.isEmpty());
      assertNull(strBuilder0.getNewLineText());
      assertEquals(574, strBuilder0.capacity());
      assertNull(strBuilder0.getNullText());
      assertEquals(0, strBuilder0.size());
      
      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\'');
      assertNotNull(strBuilder1);
      assertSame(strBuilder0, strBuilder1);
      assertSame(strBuilder1, strBuilder0);
      assertEquals(574, strBuilder0.length());
      assertEquals(574, strBuilder0.size());
      assertNull(strBuilder0.getNewLineText());
      assertEquals(574, strBuilder0.capacity());
      assertFalse(strBuilder0.isEmpty());
      assertNull(strBuilder0.getNullText());
      assertEquals(574, strBuilder1.size());
      assertFalse(strBuilder1.isEmpty());
      assertNull(strBuilder1.getNewLineText());
      assertEquals(574, strBuilder1.capacity());
      assertNull(strBuilder1.getNullText());
      assertEquals(574, strBuilder1.length());
  }"
"    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
            type = Object.class;
        }
        @SuppressWarnings(""unchecked"") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }","  public void test349()  throws Throwable  {
      // Undeclared exception!
      try { 
        ArrayUtils.add((Object[]) null, (Object) null);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Arguments cannot both be null
         //
         verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
      }
  }"
"    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
            type = Object.class;
        }
        @SuppressWarnings(""unchecked"") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }","  public void test352()  throws Throwable  {
      // Undeclared exception!
      try { 
        ArrayUtils.add((Integer[]) null, (-7), (Integer) null);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Array and element cannot both be null
         //
         verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
            int hexDigits = str.length() - 2; // drop 0x
            if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test035()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""--X+.\""LnzwmpM1g+fl"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // --X+.\""LnzwmpM1g+fl is not a valid number.
         //
         verifyException(""org.apache.commons.lang3.math.NumberUtils"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
            int hexDigits = str.length() - 2; // drop 0x
            if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test047()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""--0XVG\""AMz:>EyhF"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // --0XVG\""AMz:>EyhF is not a valid number.
         //
         verifyException(""org.apache.commons.lang3.math.NumberUtils"", e);
      }
  }"
"    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        // initial parameter checks
        if (str == null) {
            return null;
        }
        if (str.length() == 0) {
            return StringUtils.EMPTY;
        }

        // if the lower value is greater than the length of the string,
        // set to the length of the string
        // if the upper value is -1 (i.e. no limit) or is greater
        // than the length of the string, set to the length of the string
        if (upper == -1 || upper > str.length()) {
            upper = str.length();
        }
        // if upper is less than lower, raise it to lower
        if (upper < lower) {
            upper = lower;
        }

        StringBuffer result = new StringBuffer();
        int index = StringUtils.indexOf(str, "" "", lower);
        if (index == -1) {
            result.append(str.substring(0, upper));
            // only if abbreviation has occured do we append the appendToEnd value
            if (upper != str.length()) {
                result.append(StringUtils.defaultString(appendToEnd));
            }
        } else if (index > upper) {
            result.append(str.substring(0, upper));
            result.append(StringUtils.defaultString(appendToEnd));
        } else {
            result.append(str.substring(0, index));
            result.append(StringUtils.defaultString(appendToEnd));
        }
        return result.toString();
    }","  public void test30()  throws Throwable  {
      String string0 = WordUtils.abbreviate(""wTDdt<TJing. Mac"", 421, 13, "" "");
      assertEquals(""wTDdt<TJing. Mac"", string0);
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test00()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.US;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"" ; gave up at index 83
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test01()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.ENGLISH;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""HZJV^H"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""HZJV^H\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test02()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone(""WyGf<\""J"");
      Locale locale0 = Locale.CHINESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""WyGf<\""J"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""WyGf<\""J\"" ; gave up at index 3
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test17()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.FRANCE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""`@Z$=yy`/|$~1LALU&P"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""`@Z$=yy`/|$~1LALU&P\"" ; gave up at index 13
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test21()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""S(X"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""S(X\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test23()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.CHINESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""W*f<\""T(HJH"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""W*f<\""T(HJH\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test25()  throws Throwable  {
      Locale locale0 = new Locale(""Zt`q("", ""Zt`q("", ""Zt`q("");
      TimeZone timeZone0 = TimeZone.getTimeZone(""Zt`q("");
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""-7|@]F5Tc%m($PLP~tw"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""-7|@]F5Tc%m($PLP~tw\"" ; gave up at index 7
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test27()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.GERMAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""/,q3rndcZ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""/,q3rndcZ\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test29()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone("";J&%Dl.p[7Zh_nAhzE"");
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""FH2(bMqDjaKCbX"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""FH2(bMqDjaKCbX\"" ; gave up at index 4
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test30()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""3fr&HfA"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""3fr&HfA\"" ; gave up at index 1
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test31()  throws Throwable  {
      Locale locale0 = new Locale(""6I"", ""6I"", ""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"");
      TimeZone timeZone0 = TimeZone.getTimeZone(""SNXk?8a4BQ_3A|Q+i"");
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""6I"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""6I\"" ; gave up at index 1
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test33()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.GERMAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""88vf,z'r"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""88vf,z'r\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test34()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone(""9*f<\""H*H"");
      Locale locale0 = Locale.US;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""9*f<\""H*H"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""9*f<\""H*H\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test36()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.JAPANESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""`@Z=yy`/|$~1LALU&P"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""`@Z=yy`/|$~1LALU&P\"" ; gave up at index 12
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test37()  throws Throwable  {
      Locale locale0 = Locale.ENGLISH;
      TimeZone timeZone0 = TimeZone.getDefault();
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""]k>QHlD*"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""]k>QHlD*\"" ; gave up at index 3
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test39()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""@SKFxk)?Aeh4iJ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""@SKFxk)?Aeh4iJ\"" ; gave up at index 4
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return ArrayUtils.EMPTY_CLASS_ARRAY;
        }
        Class<?>[] classes = new Class[array.length];
        for (int i = 0; i < array.length; i++) {
            classes[i] = array[i].getClass();
        }
        return classes;
    }","  public void test73()  throws Throwable  {
      Object[] objectArray0 = new Object[3];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
      assertEquals(3, classArray0.length);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && isDigits(numeric.substring(1))
                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test030()  throws Throwable  {
      Number number0 = NumberUtils.createNumber(""6l"");
      assertEquals(6L, number0);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test017()  throws Throwable  {
      try { 
        NumberUtils.createNumber("".."");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.math.BigDecimal"", e);
      }
  }"
"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }","  public void test18()  throws Throwable  {
      boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);
      assertFalse(boolean0);
  }"
"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }","  public void test19()  throws Throwable  {
      Locale locale0 = Locale.ENGLISH;
      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);
      assertTrue(boolean0);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test023()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""0Xz46Pe"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \""z46Pe\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test024()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""-0X"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \""-\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
"    public static String getPackageName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getPackageName(object.getClass());
    }","  public void test21()  throws Throwable  {
      // Undeclared exception!
      try { 
        ClassUtils.getPackageName(""["");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test2()  throws Throwable  {
      char[] charArray0 = new char[7];
      charArray0[3] = '&';
      charArray0[4] = '#';
      charArray0[5] = 'X';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0000\u0000\u0000&#X\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test3()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[3] = '&';
      charArray0[4] = '#';
      charArray0[5] = 'X';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0000\u0000\u0000&#X"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test4()  throws Throwable  {
      char[] charArray0 = new char[3];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'b';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#b"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test5()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = '4';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0004\u0000\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test6()  throws Throwable  {
      char[] charArray0 = new char[5];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'l';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#l\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test7()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'B';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#B\u0000\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test8()  throws Throwable  {
      char[] charArray0 = new char[3];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = '4';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0004"", string0);
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test03()  throws Throwable  {
      FastDateFormat.getInstance(""zwSDshmD{kc5G"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test23()  throws Throwable  {
      FastDateFormat.getInstance(""<{H#AMf"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test24()  throws Throwable  {
      FastDateFormat.getInstance(""%5FBU6V+=$JW5@7p"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test25()  throws Throwable  {
      FastDateFormat.getInstance(""2C oyYB9sU>d"");
  }"
