focal_method,test_prefix
"    public List getValues(final Option option,
                          List defaultValues) {
        // initialize the return list
        List valueList = (List) values.get(option);

        // grab the correct default values
        if ((valueList == null) || valueList.isEmpty()) {
            valueList = defaultValues;
        }

        // augment the list with the default values
        if ((valueList == null) || valueList.isEmpty()) {
            valueList = (List) this.defaultValues.get(option);
        }
                // if there are more default values as specified, add them to
                // the list.
                    // copy the list first
        
        return valueList == null ? Collections.EMPTY_LIST : valueList;
    }","  public void test12()  throws Throwable  {
      LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
      PropertyOption propertyOption0 = PropertyOption.INSTANCE;
      WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
      List list0 = writeableCommandLineImpl0.getOptions();
      FileValidator fileValidator0 = FileValidator.getExistingDirectoryInstance();
      ArgumentImpl argumentImpl0 = new ArgumentImpl(""[af`YR"", ""DJ;%"", 124, 124, 'I', 'I', fileValidator0, ""Option.missing.required"", list0, 124);
      writeableCommandLineImpl0.addSwitch(argumentImpl0, false);
      writeableCommandLineImpl0.addValue(argumentImpl0, ""Option.missing.required"");
      List list1 = writeableCommandLineImpl0.getValues((Option) argumentImpl0, (List) list0);
      assertEquals(2, list1.size());
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                processSingleHyphen(token);
            }
            else if (token.startsWith(""-""))
            {
                int tokenLength = token.length();

                if (tokenLength == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else
            {
                if (stopAtNonOption)
                {
                    process(token);
                }
                else
                {
                    tokens.add(token);
                }
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test3()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-ub\""vdz(*j"";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      assertEquals(3, stringArray1.length);
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                processSingleHyphen(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                process(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test4()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""- "";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      assertEquals(2, stringArray1.length);
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo

                if (!options.hasOption(opt))
                {
                    processNonOptionToken(token);
                }
                else
                {
                    
                    tokens.add(opt);
                    if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test4()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      options0.addOption(""P"", true, ""T"");
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-PE---"";
      stringArray0[1] = ""-8"";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      String[] stringArray2 = posixParser0.flatten(options0, stringArray1, true);
      assertEquals(5, stringArray2.length);
}"
"    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)
    {
        final String lpad = createPadding(leftPad);
        final String dpad = createPadding(descPad);

        // first create list containing only <lpad>-a,--aaa where 
        // -a is opt and --aaa is long opt; in parallel look for 
        // the longest opt string this list will be then used to 
        // sort options ascending
        int max = 0;
        StringBuffer optBuf;
        List prefixList = new ArrayList();

        List optList = options.helpOptions();

        Collections.sort(optList, getOptionComparator());

        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            Option option = (Option) i.next();
            optBuf = new StringBuffer(8);

            if (option.getOpt() == null)
            {
                optBuf.append(lpad).append(""   "" + defaultLongOptPrefix).append(option.getLongOpt());
            }
            else
            {
                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());

                if (option.hasLongOpt())
                {
                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());
                }
            }

            if (option.hasArg())
            {
                if (option.hasArgName())
                {
                    optBuf.append("" <"").append(option.getArgName()).append("">"");
                }
                else
                {
                    optBuf.append(' ');
                }
            }

            prefixList.add(optBuf);
            max = (optBuf.length() > max) ? optBuf.length() : max;
        }

        int x = 0;

        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            Option option = (Option) i.next();
            optBuf = new StringBuffer(prefixList.get(x++).toString());

            if (optBuf.length() < max)
            {
                optBuf.append(createPadding(max - optBuf.length()));
            }

            optBuf.append(dpad);

            int nextLineTabStop = max + descPad;

            if (option.getDescription() != null)
            {
                optBuf.append(option.getDescription());
            }

            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());

            if (i.hasNext())
            {
                sb.append(defaultNewLine);
            }
        }

        return sb;
    }","  public void test26()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      StringBuffer stringBuffer0 = new StringBuffer();
      Options options0 = new Options();
      Options options1 = options0.addOption(""t"", false, ""--"");
      helpFormatter0.renderOptions(stringBuffer0, 68, options1, 144, 1);
      assertEquals(37, stringBuffer0.length());
}"
"    static String stripLeadingAndTrailingQuotes(String str)
    {
        if (str.startsWith(""\""""))
        {
            str = str.substring(1, str.length());
        }
        int length = str.length();
        if (str.endsWith(""\""""))
        {
            str = str.substring(0, length - 1);
        }
        
        return str;
    }","  public void test6()  throws Throwable  {
      String string0 = Util.stripLeadingAndTrailingQuotes(""\""qDxD_5>q,)`dEgM"");
      assertEquals(""\""qDxD_5>q,)`dEgM"", string0);
}"
"    static String stripLeadingAndTrailingQuotes(String str)
    {
        if (str.startsWith(""\""""))
        {
            str = str.substring(1, str.length());
        }
        int length = str.length();
        if (str.endsWith(""\""""))
        {
            str = str.substring(0, length - 1);
        }
        
        return str;
    }","  public void test8()  throws Throwable  {
      String string0 = Util.stripLeadingAndTrailingQuotes(""\""\"" |B_#\"""");
      assertEquals(""\""\"" |B_#\"""", string0);
}"
"    public boolean hasArgName()
    {
        return argName != null && argName.length() > 0;
    }","  public void test20()  throws Throwable  {
      Option option0 = new Option(""4"", ""4"");
      boolean boolean0 = option0.hasArgName();
      assertFalse(boolean0);
}"
"    public Object getType()
    {
        return type;
    }","  public void test09()  throws Throwable  {
      Option option0 = new Option("""", """", true, ""'"");
      Object object0 = option0.getType();
      assertNotNull(object0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test34()  throws Throwable  {
      Option option0 = new Option("""", """");
      String string0 = option0.toString();
      assertEquals(""[ option:   ::  :: class java.lang.String ]"", string0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test33()  throws Throwable  {
      Option option0 = new Option("""", ""X84U-w?C*"", true, """");
      String string0 = option0.toString();
      assertEquals(""[ option:  X84U-w?C*  [ARG] ::  :: class java.lang.String ]"", string0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test23()  throws Throwable  {
      Option option0 = new Option("""", """");
      option0.setArgs((-2));
      String string0 = option0.toString();
      assertEquals(""[ option:  [ARG...] ::  :: class java.lang.String ]"", string0);
}"
"    public static boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }","  public void test37()  throws Throwable  {
      byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
      boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
      assertFalse(boolean0);
}"
"    static byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }","  public void test34()  throws Throwable  {
      byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
      byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
      assertEquals(2, byteArray1.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test05()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[1] = (byte) (-18);
      byteArray0[2] = (byte)1;
      byteArray0[3] = (byte)9;
      byteArray0[4] = (byte) (-18);
      byteArray0[5] = (byte)96;
      byteArray0[6] = (byte)9;
      byteArray0[8] = (byte)16;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      byte[] byteArray4 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray3);
      assertEquals(166, byteArray4.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[6] = (byte)9;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      assertEquals(90, byteArray3.length);
}"
"    public byte[] encode(byte[] bytes) {
        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
    }","  public void test07()  throws Throwable  {
      QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();
      byte[] byteArray0 = new byte[4];
      byteArray0[3] = (byte)9;
      byte[] byteArray1 = quotedPrintableCodec0.encode(byteArray0);
      assertEquals(12, byteArray1.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test06()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)53;
      byteArray0[1] = (byte) (-18);
      byteArray0[2] = (byte)1;
      byteArray0[5] = (byte)96;
      byteArray0[6] = (byte)9;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      assertEquals(80, byteArray3.length);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);
      Base64 base64_0 = new Base64((-2146420536));
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, true);
      long long0 = baseNCodecInputStream0.skip(597);
      assertEquals(0L, long0);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test11()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base32 base32_0 = new Base32();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);
      int int0 = baseNCodecInputStream0.available();
      assertEquals(1, int0);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base32 base32_0 = new Base32();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      base32_0.encodeToString(byteArray0);
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);
      int int0 = baseNCodecInputStream0.available();
      assertEquals(0, int0);
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test06()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)2);
      cpioArchiveOutputStream0.close();
      assertEquals(""0707020000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test01()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      cpioArchiveOutputStream0.close();
      assertEquals(""q\uFFFD\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\uFFFD\uFFFD\uFFFD\uFFFD\u0000\u000B\u0000\u0000\u0000\u0000TRAILER!!!\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test21()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0);
      cpioArchiveOutputStream0.close();
      cpioArchiveOutputStream0.close();
      assertEquals(""0707010000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test04()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)4);
      cpioArchiveOutputStream0.close();
      assertEquals(""0707070000000000000000000000000000000000010000007777777777700001300000000000TRAILER!!!\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            this.finish();
            out.close();
            this.closed = true;
        }
    }","  public void test10()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      cpioArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
}"
"    public void close() throws IOException {
        finish();
        if (raf != null) {
            raf.close();
        }
        if (out != null) {
            out.close();
        }
    }","  public void test22()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      zipArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
}"
"    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ZipArchiveEntry other = (ZipArchiveEntry) obj;
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        return true;
    }","  public void test29()  throws Throwable  {
      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
      ZipArchiveEntry zipArchiveEntry1 = new ZipArchiveEntry(""y"");
      boolean boolean0 = zipArchiveEntry1.equals(zipArchiveEntry0);
      assertFalse(boolean0);
}"
"    public long getBytesWritten() {
        return bytesWritten;
    }","  public void test07()  throws Throwable  {
      File file0 = MockFile.createTempFile(""Ou{e 6;.kh"", ""Ou{e 6;.kh"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
      TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);
      tarArchiveOutputStream0.close();
      tarArchiveOutputStream0.close();
      assertEquals(10240L, tarArchiveOutputStream0.getBytesWritten());
}"
"    public ZipShort getCentralDirectoryLength() {
        return getLocalFileDataLength();
    }","  public void test04()  throws Throwable  {
      X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
      ZipShort zipShort0 = x7875_NewUnix0.getCentralDirectoryLength();
      assertEquals(0, zipShort0.getValue());
}"
"    public void close() throws IOException {
        if (!finished) {
            finish();
        }
        destroy();
    }","  public void test33()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      zipArchiveOutputStream0.finish();
      zipArchiveOutputStream0.close();
      assertEquals(""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)
            throws IOException {
        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);
        if (hasZip64Extra(ae)) {
            // Will be re-added as required. this may make the file generated with this method
            // somewhat smaller than standard mode,
            // since standard mode is unable to remove the zip 64 header.
            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
        }
        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN
                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN
                && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;
        putArchiveEntry(ae, is2PhaseSource);
        copyFromZipInputStream(rawStream);
        closeCopiedEntry(is2PhaseSource);
    }","  public void test18()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""AUy(e'"", true);
      zipArchiveOutputStream0.putArchiveEntry(zipArchiveEntry0);
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(""AUy(e'"");
      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);
      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);
      assertEquals(""PK\u0003\u0004\u0014\u0000\b\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0007\b\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDPK\u0003\u0004\u0014\u0000\u0000\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    int readEscape() throws IOException {
        // the escape char has just been read (normally a backslash)
        final int c = in.read();
        switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF: // TODO is this correct?
        case TAB: // TODO is this correct? Do tabs need to be escaped?
        case BACKSPACE: // TODO is this correct?
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
                return c;
            // indicate unexpected char - available from in.getLastChar()
        }
    }","  public void test07()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
      StringReader stringReader0 = new StringReader(""QU,rs$@LR&/"");
      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
      cSVLexer0.readEscape();
      int int0 = cSVLexer0.readEscape();
      assertEquals((-1), int0);
}"
"    int readEscape() throws IOException {
        // the escape char has just been read (normally a backslash)
        final int c = in.read();
        switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF: // TODO is this correct?
        case TAB: // TODO is this correct? Do tabs need to be escaped?
        case BACKSPACE: // TODO is this correct?
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
                return c;
            // indicate unexpected char - available from in.getLastChar()
        }
    }","  public void test10()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.csv.CSVLexer"");
      Character character0 = new Character('\'');
      Quote quote0 = Quote.ALL;
      Character character1 = new Character('a');
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, character1, character0, false, true, ""org.apache.commons.csv.CSVLexer"", (String) null, stringArray0);
      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
      cSVLexer0.readEscape();
      int int0 = cSVLexer0.readEscape();
      int int1 = cSVLexer0.readEscape();
      assertEquals((-1), int1);
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test35()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
      CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString("""");
      cSVFormat1.hashCode();
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test11()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('q');
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test33()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      String[] stringArray0 = new String[3];
      stringArray0[1] = ""The header contains a duplicate entry: '"";
      stringArray0[2] = ""c[0TyZhMn}#&:L"";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      cSVFormat1.format(stringArray0);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test40()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      String[] stringArray0 = new String[3];
      stringArray0[1] = ""The header contains a duplicate entry: '"";
      stringArray0[2] = ""c[0TyZhMn}#&:L"";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      String string0 = cSVFormat1.toString();
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test29()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The comment start and the escape character cannot be the same ('"");
      cSVFormat1.equals(cSVFormat0);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test23()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('y');
      boolean boolean0 = cSVFormat0.equals(cSVFormat1);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test11()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test02()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      QuoteMode quoteMode0 = QuoteMode.MINIMAL;
      CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
      cSVFormat1.hashCode();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""Delimiter=<"").append(delimiter).append('>');
        if (isEscapeCharacterSet()) {
            sb.append(' ');
            sb.append(""Escape=<"").append(escapeCharacter).append('>');
        }
        if (isQuoteCharacterSet()) {
            sb.append(' ');
            sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
        }
        if (isCommentMarkerSet()) {
            sb.append(' ');
            sb.append(""CommentStart=<"").append(commentMarker).append('>');
        }
        if (isNullStringSet()) {
            sb.append(' ');
            sb.append(""NullString=<"").append(nullString).append('>');
        }
        if (recordSeparator != null) {
            sb.append(' ');
            sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
        }
        if (getIgnoreEmptyLines()) {
            sb.append("" EmptyLines:ignored"");
        }
        if (getIgnoreSurroundingSpaces()) {
            sb.append("" SurroundingSpaces:ignored"");
        }
        if (getIgnoreHeaderCase()) {
            sb.append("" IgnoreHeaderCase:ignored"");
        }
        sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
        if (headerComments != null) {
            sb.append(' ');
            sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
        }
        if (header != null) {
            sb.append(' ');
            sb.append(""Header:"").append(Arrays.toString(header));
        }
        return sb.toString();
    }","  public void test45()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      String string0 = cSVFormat1.toString();
      assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> SkipHeaderRecord:false Header:[]"", string0);
}"
"    public String getNullString() {
        return nullString;
    }","  public void test33()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('$');
      cSVFormat0.equals(cSVFormat1);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test34()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      cSVFormat1.getHeader();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test25()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      Character character0 = Character.valueOf('8');
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
      CSVFormat cSVFormat2 = cSVFormat1.withEscape('?');
      boolean boolean0 = cSVFormat1.equals(cSVFormat2);
      assertEquals(""\\N"", cSVFormat2.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test21()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withQuote('c');
      boolean boolean0 = cSVFormat0.equals(cSVFormat1);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test23()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      Character character0 = Character.valueOf('8');
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
      boolean boolean0 = cSVFormat1.equals(cSVFormat0);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public char[] expandCurrentSegment()
    {
        final char[] curr = _currentSegment;
        // Let's grow by 50% by default
        final int len = curr.length;
        // but above intended maximum, slow to increase by 25%
        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));
        return (_currentSegment = Arrays.copyOf(curr, newLen));
    }","  public void test45()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      char[] charArray0 = textBuffer0.getCurrentSegment();
      textBuffer0.expandCurrentSegment(262144);
      char[] charArray1 = textBuffer0.expandCurrentSegment();
      assertEquals(327680, charArray1.length);
}"
"    public int writeValue() {
        // Most likely, object:
        if (_type == TYPE_OBJECT) {
            _gotName = false;
            ++_index;
            return STATUS_OK_AFTER_COLON;
        }

        // Ok, array?
        if (_type == TYPE_ARRAY) {
            int ix = _index;
            ++_index;
            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;
        }
        
        // Nope, root context
        // No commas within root context, but need space
        ++_index;
        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;
    }","  public void test12()  throws Throwable  {
      DupDetector dupDetector0 = DupDetector.rootDetector((JsonParser) null);
      JsonWriteContext jsonWriteContext0 = JsonWriteContext.createRootContext(dupDetector0);
      JsonWriteContext jsonWriteContext1 = jsonWriteContext0.createChildObjectContext();
      int int0 = jsonWriteContext1.writeValue();
      assertEquals(5, int0);
}"
"    public char[] getTextBuffer()
    {
        // Are we just using shared input buffer?
        if (_inputStart >= 0) return _inputBuffer;
        if (_resultArray != null)  return _resultArray;
        if (_resultString != null) {
            return (_resultArray = _resultString.toCharArray());
        }
        // Nope; but does it fit in just one segment?
        if (!_hasSegments)  return _currentSegment;
        // Nope, need to have/create a non-segmented array and return it
        return contentsAsArray();
    }","  public void test27()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithEmpty();
      char[] charArray0 = textBuffer0.getTextBuffer();
      assertNotNull(charArray0);
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test50()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      filteringParserDelegate0._nextToken2();
      boolean boolean0 = filteringParserDelegate0.isExpectedStartArrayToken();
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test43()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      filteringParserDelegate0._nextToken2();
      boolean boolean0 = filteringParserDelegate0.hasTokenId(33);
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test67()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, false);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      FilteringParserDelegate filteringParserDelegate1 = new FilteringParserDelegate(filteringParserDelegate0, tokenFilter0, false, false);
      filteringParserDelegate0.nextToken();
      filteringParserDelegate1.nextValue();
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test08()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<String> class2 = String.class;
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 1006);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      Class<Error> class3 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class3);
      mapDeserializer0.withResolved(stdKeyDeserializer_StringKD0, (TypeDeserializer) null, mapDeserializer0, linkedHashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test09()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<MapperFeature> class2 = MapperFeature.class;
      CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class2, 10);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, coreXMLDeserializers_Std0, (TypeDeserializer) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      TypeFactory typeFactory0 = TypeFactory.defaultInstance();
      ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
      Class<InputStream> class3 = InputStream.class;
      AsWrapperTypeDeserializer asWrapperTypeDeserializer0 = new AsWrapperTypeDeserializer(collectionLikeType0, classNameIdResolver0, """", false, class3);
      mapDeserializer0.withResolved((KeyDeserializer) null, asWrapperTypeDeserializer0, coreXMLDeserializers_Std0, hashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test07()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class0, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 3980);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      mapDeserializer0.getContentType();
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test02()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      JavaType javaType0 = mapDeserializer0.getValueType();
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test01()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      MapDeserializer mapDeserializer1 = new MapDeserializer(mapDeserializer0);
      assertFalse(mapDeserializer1.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test20()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, simpleType0);
      Class<Integer> class1 = Integer.class;
      StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class1);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, stdKeyDeserializer0, (JsonDeserializer<Object>) null, (TypeDeserializer) null);
      boolean boolean0 = mapDeserializer0.isCachable();
      assertFalse(boolean0);
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test18()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<Error> class2 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);
      boolean boolean0 = mapDeserializer0.isCachable();
      assertFalse(boolean0);
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test15()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<Error> class2 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);
      BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
      DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
      mapDeserializer0.resolve(defaultDeserializationContext_Impl0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test13()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      String[] stringArray0 = new String[0];
      mapDeserializer0.setIgnorableProperties(stringArray0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test11()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      mapDeserializer0.setIgnorableProperties((String[]) null);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test10()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      MapDeserializer mapDeserializer1 = mapDeserializer0.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);
      MapDeserializer mapDeserializer2 = mapDeserializer1.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test14()  throws Throwable  {
      StdDateFormat stdDateFormat0 = StdDateFormat.instance;
      boolean boolean0 = stdDateFormat0.isLenient();
      assertFalse(boolean0);
}"
"    public Object generateId(Object forPojo) {
        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of
        //    id being generated for ""alwaysAsId"", but not being written as POJO; regardless,
        //    need to use existing id if there is one:
            id = generator.generateId(forPojo);
        return id;
    }","  public void test4()  throws Throwable  {
      ObjectIdGenerators.IntSequenceGenerator objectIdGenerators_IntSequenceGenerator0 = new ObjectIdGenerators.IntSequenceGenerator();
      WritableObjectId writableObjectId0 = new WritableObjectId(objectIdGenerators_IntSequenceGenerator0);
      writableObjectId0.generateId(objectIdGenerators_IntSequenceGenerator0);
      Object object0 = new Object();
      Object object1 = writableObjectId0.generateId(object0);
      assertEquals((-1), object1);
}"
"    public String toString()
    {
        return new StringBuilder(40)
            .append(""[reference type, class "")
            .append(buildCanonicalName())
            .append('<')
            .append(_referencedType)
            .append('>')
            .append(']')
            .toString();
    }","  public void test03()  throws Throwable  {
      SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
      ReferenceType referenceType0 = new ReferenceType(simpleType0, simpleType0);
      String string0 = referenceType0.toString();
      assertEquals(""[reference type, class java.lang.Object<java.lang.Object><[simple type, class java.lang.Object]>]"", string0);
}"
"    public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
    {
        if (_classNames.contains(clsName)) {
            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
            if (d != null) {
                return d;
            }
            if (rawType == UUID.class) {
                return new UUIDDeserializer();
            }
            if (rawType == StackTraceElement.class) {
                return new StackTraceElementDeserializer();
            }
            if (rawType == AtomicBoolean.class) {
                // (note: AtomicInteger/Long work due to single-arg constructor. For now?
                return new AtomicBooleanDeserializer();
            }
            if (rawType == ByteBuffer.class) {
                return new ByteBufferDeserializer();
            }
        }
        return null;
    }","  public void test5()  throws Throwable  {
      Class<Void> class0 = Void.class;
      JsonDeserializer<?> jsonDeserializer0 = JdkDeserializers.find(class0, ""com.fasterxml.jackson.databind.JavaType"");
      assertNotNull(jsonDeserializer0);
}"
"    static String escape(String string, Document.OutputSettings out) {
        return escape(string, out.encoder(), out.escapeMode());
    }","  public void test3()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      CharsetEncoder charsetEncoder0 = charset0.newEncoder();
      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.extended;
      String string0 = Entities.escape(""Fo%^]N={*!BXG'NZQ"", charsetEncoder0, entities_EscapeMode0);
      assertEquals(""Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ"", string0);
}"
"    static String unescape(String string) {
        if (!string.contains(""&""))
            return string;

        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs

        while (m.find()) {
            int charval = -1;
            String num = m.group(3);
            if (num != null) {
                try {
                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                    charval = Integer.valueOf(num, base);
                } catch (NumberFormatException e) {
                } // skip
            } else {
                String name = m.group(1).toLowerCase();
                if (full.containsKey(name))
                    charval = full.get(name);
            }

            if (charval != -1 || charval > 0xFFFF) { // out of range
                String c = Character.toString((char) charval);
                m.appendReplacement(accum, c);
            } else {
                m.appendReplacement(accum, m.group(0)); // replace with original string
            }
        }
        m.appendTail(accum);
        return accum.toString();
    }","  public void test4()  throws Throwable  {
      String string0 = Entities.unescape(""Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ"");
      assertEquals(""Fo%^]N={*!BXG'NZQ"", string0);
}"
"    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
        accum.append(""<!DOCTYPE html"");
        if (!StringUtil.isBlank(attr(""publicId"")))
            accum.append("" PUBLIC \"""").append(attr(""publicId"")).append(""\"""");
        if (!StringUtil.isBlank(attr(""systemId"")))
            accum.append(' ').append(attr(""systemId"")).append(""\"""");
        accum.append('>');
    }","  public void test1()  throws Throwable  {
      DocumentType documentType0 = new DocumentType(""ygL0pop.]WM:R$swY0g"", ""ygL0pop.]WM:R$swY0g"", ""ygL0pop.]WM:R$swY0g"", ""s)XlM.FRp.@;D$"");
      Attributes attributes0 = new Attributes();
      documentType0.attributes = attributes0;
      StringBuilder stringBuilder0 = new StringBuilder();
      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
      documentType0.outerHtmlHead(stringBuilder0, 1, document_OutputSettings0);
      assertEquals(""<!DOCTYPE >"", stringBuilder0.toString());
}"
"    public DocumentType(String name, String publicId, String systemId, String baseUri) {
        super(baseUri);

        attr(""name"", name);
        attr(""publicId"", publicId);
        attr(""systemId"", systemId);
    }","  public void test0()  throws Throwable  {
      DocumentType documentType0 = new DocumentType(""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"");
      String string0 = documentType0.outerHtml();
      assertEquals(""<!DOCTYPE /:u'$8-DkwD}/:5 PUBLIC \""/:u'$8-DkwD}/:5\"" \""/:u'$8-DkwD}/:5\"">"", string0);
}"
"    boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
        TagName tag = TagName.valueOf(tagName);
        AttributeKey key = AttributeKey.valueOf(attr.getKey());

        if (attributes.containsKey(tag)) {
            if (attributes.get(tag).contains(key)) {
                if (protocols.containsKey(tag)) {
                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);
                    // ok if not defined protocol; otherwise test
                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));
                } else { // attribute found, no protocols defined, so OK
                    return true;
                }
            }
        } else { // no attributes defined for tag, try :all tag
            return !tagName.equals("":all"") && isSafeAttribute("":all"", el, attr);
        }
        return false;
    }","  public void test10()  throws Throwable  {
      Whitelist whitelist0 = Whitelist.basicWithImages();
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""cite"";
      stringArray0[1] = ""h5WK''"";
      stringArray0[2] = ""h5WK''"";
      Whitelist whitelist1 = whitelist0.addAttributes(""cite"", stringArray0);
      Document document0 = new Document(""h5WK''"");
      Attribute attribute0 = Attribute.createFromEncoded(""cite"", ""http:h5wk''"");
      boolean boolean0 = whitelist1.isSafeAttribute(""cite"", document0, attribute0);
      assertTrue(boolean0);
}"
"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }","  public void test0()  throws Throwable  {
      Whitelist whitelist0 = new Whitelist();
      Cleaner cleaner0 = new Cleaner(whitelist0);
      Document document0 = Document.createShell(""org.jsoup.safeG Cleae$IlanrngVisitor"");
      whitelist0.addEnforcedAttribute(""body"", ""<html>\n <head></head>\n <body></body>\n</html>"", ""org.jsoup.safeG Cleae$IlanrngVisitor"");
      Document document1 = cleaner0.clean(document0);
      boolean boolean0 = cleaner0.isValid(document1);
      assertFalse(boolean0);
}"
"    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        Element element = (Element) o;

        return this == o;
    }","  public void test69()  throws Throwable  {
      Document document0 = new Document(""value"");
      Document document1 = new Document("">5Z"");
      boolean boolean0 = document0.equals(document1);
      assertTrue(boolean0);
}"
"    static String escape(String string, Document.OutputSettings out) {
        StringBuilder accum = new StringBuilder(string.length() * 2);
        escape(accum, string, out, false, false, false);
        return accum.toString();
    }","  public void test10()  throws Throwable  {
      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;
      document_OutputSettings0.escapeMode(entities_EscapeMode0);
      StringBuilder stringBuilder0 = new StringBuilder();
      Entities.escape(stringBuilder0, ""]?`?<DQr@*K"", document_OutputSettings0, true, true, true);
      assertEquals(""]?`?&lt;DQr@*K"", stringBuilder0.toString());
}"
"    public String toString() {
        return outerHtml();
    }","  public void test1()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""t4N7&Q"", ""NW91EkPm "", false);
      String string0 = xmlDeclaration0.toString();
      assertEquals(""<?t4N7&Q?>"", string0);
}"
"    public String getWholeDeclaration() {
        final String decl = this.name;
        if(decl.equals(""xml"") && attributes.size() > 1 ) {
            StringBuilder sb = new StringBuilder(decl);
            final String version = attributes.get(""version"");
            if( version != null ) {
                sb.append("" version=\"""").append(version).append(""\"""");
            }
            final String encoding = attributes.get(""encoding"");
            if( encoding != null ) {
                sb.append("" encoding=\"""").append(encoding).append(""\"""");
            }
            return sb.toString();
        }
        else {
            return this.name;
        }
    }","  public void test2()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""n/(:P!,Rl&n<F63$O"", ""n/(:P!,Rl&n<F63$O"", false);
      String string0 = xmlDeclaration0.getWholeDeclaration();
      assertEquals("""", string0);
}"
"    public String toString() {
        return outerHtml();
    }","  public void test3()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration("""", """", true);
      String string0 = xmlDeclaration0.toString();
      assertEquals(""<!!>"", string0);
}"
"    public int pos() {
        return readerPos + bufPos;
    }","  public void test31()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""<A)s.2T#T`V"");
      String string0 = characterReader0.consumeTagName();
      assertEquals(0, characterReader0.pos());
}"
"    public String getValue() {
        return val;
    }","  public void test04()  throws Throwable  {
      Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null);
      Attribute attribute1 = attribute0.clone();
      boolean boolean0 = attribute1.equals(attribute0);
      assertEquals("""", attribute1.getValue());
}"
"    public String getValue() {
        return val;
    }","  public void test25()  throws Throwable  {
      Attribute attribute0 = new Attribute(""7b([!ve"", (String) null);
      attribute0.hashCode();
      assertEquals("""", attribute0.getValue());
}"
"    public boolean equals(Object o) { // note parent not considered
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attribute attribute = (Attribute) o;
        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;
        return val != null ? val.equals(attribute.val) : attribute.val == null;
    }","  public void test23()  throws Throwable  {
      Attribute attribute0 = new Attribute(""RG5hzl9})]EB&"", ""RG5hzl9})]EB&"");
      Attribute attribute1 = new Attribute(""RG5hzl9})]EB&"", (String) null);
      boolean boolean0 = attribute1.equals(attribute0);
      assertTrue(attribute0.equals((Object)attribute1));
}"
"    public String getValue() {
        return val;
    }","  public void test20()  throws Throwable  {
      Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null);
      boolean boolean0 = attribute0.equals(attribute0);
      assertEquals("""", attribute0.getValue());
}"
"    public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }","  public void test2()  throws Throwable  {
      Constant constant0 = new Constant(""9|"");
      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual0 = new CoreOperationGreaterThanOrEqual(constant0, constant0);
      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual1 = new CoreOperationGreaterThanOrEqual(coreOperationGreaterThanOrEqual0, constant0);
      Object object0 = coreOperationGreaterThanOrEqual1.computeValue((EvalContext) null);
      assertEquals(false, object0);
}"
"    public boolean testNode(NodeTest test) {
        return testNode(node, test);
    }","  public void test24()  throws Throwable  {
      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();
      Locale locale0 = Locale.FRENCH;
      HTMLTableElementImpl hTMLTableElementImpl0 = new HTMLTableElementImpl(hTMLDocumentImpl0, ""Unknown namespace prefix: "");
      DOMNodePointer dOMNodePointer0 = new DOMNodePointer(hTMLTableElementImpl0, locale0);
      QName qName0 = dOMNodePointer0.getName();
      NodeNameTest nodeNameTest0 = new NodeNameTest(qName0, ""http://www.w3.org/XML/1998/namespace"");
      boolean boolean0 = dOMNodePointer0.testNode((NodeTest) nodeNameTest0);
      assertTrue(boolean0);
}"
"    protected Object functionRound(EvalContext context) {
        assertArgCount(1);
        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
        return new Double(Math.round(v));
    }","  public void test79()  throws Throwable  {
      Constant constant0 = new Constant(""concat"");
      Expression[] expressionArray0 = new Expression[1];
      expressionArray0[0] = (Expression) constant0;
      CoreFunction coreFunction0 = new CoreFunction(7, expressionArray0);
      Object object0 = coreFunction0.functionRound((EvalContext) null);
      assertEquals(Double.NaN, object0);
}"
"    public boolean testNode(NodeTest test) {
        return testNode(this, node, test);
    }","  public void test30()  throws Throwable  {
      QName qName0 = new QName(""[QT~sGq>_#hT|#8m"", ""[QT~sGq>_#hT|#8m"");
      VariablePointer variablePointer0 = new VariablePointer(qName0);
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);
      boolean boolean0 = JDOMNodePointer.testNode((NodePointer) variablePointer0, (Object) null, (NodeTest) nodeTypeTest0);
      assertTrue(boolean0);
}"
"    public String asPath() {
        if (id != null) {
            return ""id('"" + escape(id) + ""')"";
        }

        StringBuffer buffer = new StringBuffer();
        if (parent != null) {
            buffer.append(parent.asPath());
        }
        switch (node.getNodeType()) {
            case Node.ELEMENT_NODE :
                // If the parent pointer is not a DOMNodePointer, it is
                // the parent's responsibility to produce the node test part
                // of the path
                if (parent instanceof DOMNodePointer) {
                    if (buffer.length() == 0
                            || buffer.charAt(buffer.length() - 1) != '/') {
                        buffer.append('/');
                    }
                    String ln = DOMNodePointer.getLocalName(node);
                    String nsURI = getNamespaceURI();
                    if (nsURI == null) {
                        buffer.append(ln);
                        buffer.append('[');
                        buffer.append(getRelativePositionByQName()).append(']');
                    }
                    else {
                        String prefix = getNamespaceResolver().getPrefix(nsURI);
                        if (prefix != null) {
                            buffer.append(prefix);
                            buffer.append(':');
                            buffer.append(ln);
                            buffer.append('[');
                            buffer.append(getRelativePositionByQName());
                            buffer.append(']');
                        }
                        else {
                            buffer.append(""node()"");
                            buffer.append('[');
                            buffer.append(getRelativePositionOfElement());
                            buffer.append(']');
                        }
                    }
                }
            break;
            case Node.TEXT_NODE :
            case Node.CDATA_SECTION_NODE :
                buffer.append(""/text()"");
                buffer.append('[');
                buffer.append(getRelativePositionOfTextNode()).append(']');
                break;
            case Node.PROCESSING_INSTRUCTION_NODE :
                buffer.append(""/processing-instruction(\'"");
                buffer.append(((ProcessingInstruction) node).getTarget()).append(""')"");
                buffer.append('[');
                buffer.append(getRelativePositionOfPI()).append(']');
                break;
            case Node.DOCUMENT_NODE :
                // That'll be empty
                break;
            default:
                break;
        }
        return buffer.toString();
    }","  public void test65()  throws Throwable  {
      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();
      DOMNodePointer dOMNodePointer0 = new DOMNodePointer((NodePointer) null, hTMLDocumentImpl0);
      PSVIDocumentImpl pSVIDocumentImpl0 = new PSVIDocumentImpl();
      Element element0 = pSVIDocumentImpl0.createElementNS("""", ""Factory could not create a child node for path: "", ""xmlns"");
      DOMNodePointer dOMNodePointer1 = new DOMNodePointer(dOMNodePointer0, element0);
      String string0 = dOMNodePointer1.asPath();
      assertEquals(""/xmlns[1]"", string0);
}"
"    public ExtendedMessageFormat(String pattern) {
        this(pattern, Locale.getDefault());
    }","  public void test08()  throws Throwable  {
      ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""*3-"");
      HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
      ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(""*3-"", hashMap0);
      boolean boolean0 = extendedMessageFormat0.equals(extendedMessageFormat1);
      assertFalse(boolean0);
}"
"    public static String getShortClassName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortClassName(object.getClass());
    }","  public void test11()  throws Throwable  {
      String string0 = ClassUtils.getShortClassName(""[LJNM-;"");
      assertEquals(""JNM-[]"", string0);
}"
"    public static String getShortCanonicalName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortCanonicalName(object.getClass().getName());
    }","  public void test12()  throws Throwable  {
      String string0 = ClassUtils.getShortCanonicalName(""["");
      assertEquals(""][]"", string0);
}"
"    public static String getShortClassName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortClassName(object.getClass());
    }","  public void test13()  throws Throwable  {
      String string0 = ClassUtils.getShortClassName(""[[LJNM-"");
      assertEquals(""LJNM-[][]"", string0);
}"
"    public static String getShortCanonicalName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortCanonicalName(object.getClass().getName());
    }","  public void test14()  throws Throwable  {
      String string0 = ClassUtils.getShortCanonicalName(""B"");
      assertEquals(""byte"", string0);
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test09()  throws Throwable  {
      String string0 = StringEscapeUtils.escapeJava(""OZw9N)RwzH/"");
      assertEquals(""OZw9N)RwzH/"", string0);
}"
"    public int getDenominator() {
        return denominator;
    }","  public void test28()  throws Throwable  {
      Fraction fraction0 = Fraction.getFraction(0, 394);
      Fraction fraction1 = fraction0.reduce();
      assertEquals(1, fraction1.getDenominator());
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test08()  throws Throwable  {
      String string0 = ""<<\\u+ob%jNBH/"";
      String string1 = StringEscapeUtils.escapeJava(string0);
      assertEquals(""<<\\\\u+ob%jNBH\\/"", string1);
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test09()  throws Throwable  {
      String string0 = StringEscapeUtils.escapeJava(""3b#H/LYs'XYVNA3|'T"");
      assertEquals(""3b#H\\/LYs'XYVNA3|'T"", string0);
}"
"    public static Date truncate(Date date, int field) {
        if (date == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
        Calendar gval = Calendar.getInstance();
        gval.setTime(date);
        modify(gval, field, false);
        return gval.getTime();
    }","  public void test53()  throws Throwable  {
      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;
      Locale locale0 = Locale.CANADA;
      Calendar calendar0 = MockCalendar.getInstance((TimeZone) zoneInfo0, locale0);
      Calendar calendar1 = DateUtils.truncate(calendar0, 13);
      assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", calendar1.toString());
}"
"    public static Date round(Date date, int field) {
        if (date == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
        Calendar gval = Calendar.getInstance();
        gval.setTime(date);
        modify(gval, field, true);
        return gval.getTime();
    }","  public void test54()  throws Throwable  {
      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
      Date date0 = DateUtils.round((Object) mockGregorianCalendar0, 12);
      assertEquals(""Fri Feb 14 20:21:00 GMT 2014"", date0.toString());
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test4()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(2202.502669393223, 2202.502669393223);
      Logistic logistic0 = new Logistic(2202.502669393223, 2202.502669393223, 596, (-83.763), 596, 596);
      GoalType goalType0 = GoalType.MINIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(596, (UnivariateFunction) logistic0, goalType0, 2.5339783209345245E8, (double) 596, (-2207.0263));
      assertEquals((-2207.0263), univariatePointValuePair0.getPoint(), 0.01);
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test7()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(1972.9354295246733, 1973.80211594);
      Gaussian gaussian0 = new Gaussian(2047, 2047);
      GoalType goalType0 = GoalType.MAXIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(1560, (UnivariateFunction) gaussian0, goalType0, (-1.9872713979884691E43), 0.06666666666666667, 0.06666666666666667);
      assertEquals(0.06666666666666667, univariatePointValuePair0.getPoint(), 0.01);
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test6()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(5.8015881615938497E-8, 5.8015881615938497E-8);
      Signum signum0 = new Signum();
      GoalType goalType0 = GoalType.MAXIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(2146396205, (UnivariateFunction) signum0, goalType0, 0.5469118054664329, 0.5469118054664329, 1.9017692579836876E-4);
      assertEquals(1.9017692579836876E-4, univariatePointValuePair0.getPoint(), 0.01);
}"
"    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
        clearResult();
        return localMin(getGoalType() == GoalType.MINIMIZE,
                        f, goalType, min, startValue, max,
                        getRelativeAccuracy(), getAbsoluteAccuracy());
    }","  public void test4()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer();
      double[] doubleArray0 = new double[8];
      doubleArray0[5] = Double.NaN;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      GoalType goalType0 = GoalType.MINIMIZE;
      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, 0.0, (-874.0), (-4351.645960419921));
      assertEquals(21, brentOptimizer0.getIterationCount());
}"
"    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
        clearResult();
        return localMin(getGoalType() == GoalType.MINIMIZE,
                        f, goalType, min, startValue, max,
                        getRelativeAccuracy(), getAbsoluteAccuracy());
    }","  public void test2()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer();
      double[] doubleArray0 = new double[8];
      doubleArray0[2] = (-873.217716);
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      GoalType goalType0 = GoalType.MAXIMIZE;
      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, (-873.217716), 0.0, (-1.0));
      assertEquals(56, brentOptimizer0.getEvaluations());
}"
"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }","  public void test4()  throws Throwable  {
      FDistributionImpl fDistributionImpl0 = new FDistributionImpl(763.683107623722, 1225.931330739);
      fDistributionImpl0.setDenominatorDegreesOfFreedom(1.0);
      double double0 = fDistributionImpl0.getInitialDomain((-942.0));
      assertEquals(1.0, double0, 0.01);
}"
