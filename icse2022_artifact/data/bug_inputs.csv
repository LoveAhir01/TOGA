focal_method,test_prefix
"    public List getValues(final Option option,
                          List defaultValues) {
        // initialize the return list
        List valueList = (List) values.get(option);

        // grab the correct default values
        if ((valueList == null) || valueList.isEmpty()) {
            valueList = defaultValues;
        }

        // augment the list with the default values
        if ((valueList == null) || valueList.isEmpty()) {
            valueList = (List) this.defaultValues.get(option);
        }
                // if there are more default values as specified, add them to
                // the list.
                    // copy the list first
        
        return valueList == null ? Collections.EMPTY_LIST : valueList;
    }","  public void test12()  throws Throwable  {
      LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
      PropertyOption propertyOption0 = PropertyOption.INSTANCE;
      WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
      List list0 = writeableCommandLineImpl0.getOptions();
      FileValidator fileValidator0 = FileValidator.getExistingDirectoryInstance();
      ArgumentImpl argumentImpl0 = new ArgumentImpl(""[af`YR"", ""DJ;%"", 124, 124, 'I', 'I', fileValidator0, ""Option.missing.required"", list0, 124);
      writeableCommandLineImpl0.addSwitch(argumentImpl0, false);
      writeableCommandLineImpl0.addValue(argumentImpl0, ""Option.missing.required"");
      List list1 = writeableCommandLineImpl0.getValues((Option) argumentImpl0, (List) list0);
      assertEquals(2, list1.size());
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                processSingleHyphen(token);
            }
            else if (token.startsWith(""-""))
            {
                int tokenLength = token.length();

                if (tokenLength == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else
            {
                if (stopAtNonOption)
                {
                    process(token);
                }
                else
                {
                    tokens.add(token);
                }
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test3()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""-ub\""vdz(*j"";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      assertEquals(3, stringArray1.length);
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                processSingleHyphen(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                process(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test4()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[2];
      stringArray0[0] = ""- "";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      assertEquals(2, stringArray1.length);
}"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo

                if (!options.hasOption(opt))
                {
                    processNonOptionToken(token);
                }
                else
                {
                    
                    tokens.add(opt);
                    if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test4()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      options0.addOption(""P"", true, ""T"");
      String[] stringArray0 = new String[4];
      stringArray0[0] = ""-PE---"";
      stringArray0[1] = ""-8"";
      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);
      String[] stringArray2 = posixParser0.flatten(options0, stringArray1, true);
      assertEquals(5, stringArray2.length);
}"
"    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)
    {
        final String lpad = createPadding(leftPad);
        final String dpad = createPadding(descPad);

        // first create list containing only <lpad>-a,--aaa where 
        // -a is opt and --aaa is long opt; in parallel look for 
        // the longest opt string this list will be then used to 
        // sort options ascending
        int max = 0;
        StringBuffer optBuf;
        List prefixList = new ArrayList();

        List optList = options.helpOptions();

        Collections.sort(optList, getOptionComparator());

        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            Option option = (Option) i.next();
            optBuf = new StringBuffer(8);

            if (option.getOpt() == null)
            {
                optBuf.append(lpad).append(""   "" + defaultLongOptPrefix).append(option.getLongOpt());
            }
            else
            {
                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());

                if (option.hasLongOpt())
                {
                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());
                }
            }

            if (option.hasArg())
            {
                if (option.hasArgName())
                {
                    optBuf.append("" <"").append(option.getArgName()).append("">"");
                }
                else
                {
                    optBuf.append(' ');
                }
            }

            prefixList.add(optBuf);
            max = (optBuf.length() > max) ? optBuf.length() : max;
        }

        int x = 0;

        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            Option option = (Option) i.next();
            optBuf = new StringBuffer(prefixList.get(x++).toString());

            if (optBuf.length() < max)
            {
                optBuf.append(createPadding(max - optBuf.length()));
            }

            optBuf.append(dpad);

            int nextLineTabStop = max + descPad;

            if (option.getDescription() != null)
            {
                optBuf.append(option.getDescription());
            }

            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());

            if (i.hasNext())
            {
                sb.append(defaultNewLine);
            }
        }

        return sb;
    }","  public void test26()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      StringBuffer stringBuffer0 = new StringBuffer();
      Options options0 = new Options();
      Options options1 = options0.addOption(""t"", false, ""--"");
      helpFormatter0.renderOptions(stringBuffer0, 68, options1, 144, 1);
      assertEquals(37, stringBuffer0.length());
}"
"    static String stripLeadingAndTrailingQuotes(String str)
    {
        if (str.startsWith(""\""""))
        {
            str = str.substring(1, str.length());
        }
        int length = str.length();
        if (str.endsWith(""\""""))
        {
            str = str.substring(0, length - 1);
        }
        
        return str;
    }","  public void test6()  throws Throwable  {
      String string0 = Util.stripLeadingAndTrailingQuotes(""\""qDxD_5>q,)`dEgM"");
      assertEquals(""\""qDxD_5>q,)`dEgM"", string0);
}"
"    static String stripLeadingAndTrailingQuotes(String str)
    {
        if (str.startsWith(""\""""))
        {
            str = str.substring(1, str.length());
        }
        int length = str.length();
        if (str.endsWith(""\""""))
        {
            str = str.substring(0, length - 1);
        }
        
        return str;
    }","  public void test8()  throws Throwable  {
      String string0 = Util.stripLeadingAndTrailingQuotes(""\""\"" |B_#\"""");
      assertEquals(""\""\"" |B_#\"""", string0);
}"
"    public boolean hasArgName()
    {
        return argName != null && argName.length() > 0;
    }","  public void test20()  throws Throwable  {
      Option option0 = new Option(""4"", ""4"");
      boolean boolean0 = option0.hasArgName();
      assertFalse(boolean0);
}"
"    public Object getType()
    {
        return type;
    }","  public void test09()  throws Throwable  {
      Option option0 = new Option("""", """", true, ""'"");
      Object object0 = option0.getType();
      assertNotNull(object0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test34()  throws Throwable  {
      Option option0 = new Option("""", """");
      String string0 = option0.toString();
      assertEquals(""[ option:   ::  :: class java.lang.String ]"", string0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test33()  throws Throwable  {
      Option option0 = new Option("""", ""X84U-w?C*"", true, """");
      String string0 = option0.toString();
      assertEquals(""[ option:  X84U-w?C*  [ARG] ::  :: class java.lang.String ]"", string0);
}"
"    public String toString()
    {
        StringBuffer buf = new StringBuffer().append(""[ option: "");

        buf.append(opt);

        if (longOpt != null)
        {
            buf.append("" "").append(longOpt);
        }

        buf.append("" "");

        if (hasArgs())
        {
            buf.append(""[ARG...]"");
        }
        else if (hasArg())
        {
            buf.append("" [ARG]"");
        }

        buf.append("" :: "").append(description);

        if (type != null)
        {
            buf.append("" :: "").append(type);
        }

        buf.append("" ]"");

        return buf.toString();
    }","  public void test23()  throws Throwable  {
      Option option0 = new Option("""", """");
      option0.setArgs((-2));
      String string0 = option0.toString();
      assertEquals(""[ option:  [ARG...] ::  :: class java.lang.String ]"", string0);
}"
"    public static boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }","  public void test37()  throws Throwable  {
      byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
      boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
      assertFalse(boolean0);
}"
"    static byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }","  public void test34()  throws Throwable  {
      byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
      byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
      assertEquals(2, byteArray1.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test05()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[1] = (byte) (-18);
      byteArray0[2] = (byte)1;
      byteArray0[3] = (byte)9;
      byteArray0[4] = (byte) (-18);
      byteArray0[5] = (byte)96;
      byteArray0[6] = (byte)9;
      byteArray0[8] = (byte)16;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      byte[] byteArray4 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray3);
      assertEquals(166, byteArray4.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[6] = (byte)9;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      assertEquals(90, byteArray3.length);
}"
"    public byte[] encode(byte[] bytes) {
        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
    }","  public void test07()  throws Throwable  {
      QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();
      byte[] byteArray0 = new byte[4];
      byteArray0[3] = (byte)9;
      byte[] byteArray1 = quotedPrintableCodec0.encode(byteArray0);
      assertEquals(12, byteArray1.length);
}"
"    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
        buffer.write(ESCAPE_CHAR);
        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
        buffer.write(hex1);
        buffer.write(hex2);
    }","  public void test06()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)53;
      byteArray0[1] = (byte) (-18);
      byteArray0[2] = (byte)1;
      byteArray0[5] = (byte)96;
      byteArray0[6] = (byte)9;
      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);
      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);
      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);
      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);
      assertEquals(80, byteArray3.length);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);
      Base64 base64_0 = new Base64((-2146420536));
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, true);
      long long0 = baseNCodecInputStream0.skip(597);
      assertEquals(0L, long0);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test11()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base32 base32_0 = new Base32();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);
      int int0 = baseNCodecInputStream0.available();
      assertEquals(1, int0);
}"
"    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }","  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[3];
      Base32 base32_0 = new Base32();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      base32_0.encodeToString(byteArray0);
      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);
      int int0 = baseNCodecInputStream0.available();
      assertEquals(0, int0);
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test06()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)2);
      cpioArchiveOutputStream0.close();
      assertEquals(""0707020000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test01()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      cpioArchiveOutputStream0.close();
      assertEquals(""q\uFFFD\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\uFFFD\uFFFD\uFFFD\uFFFD\u0000\u000B\u0000\u0000\u0000\u0000TRAILER!!!\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test21()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0);
      cpioArchiveOutputStream0.close();
      cpioArchiveOutputStream0.close();
      assertEquals(""0707010000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }","  public void test04()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)4);
      cpioArchiveOutputStream0.close();
      assertEquals(""0707070000000000000000000000000000000000010000007777777777700001300000000000TRAILER!!!\u0000"", byteArrayOutputStream0.toString());
}"
"    public void close() throws IOException {
        if (!this.closed) {
            this.finish();
            out.close();
            this.closed = true;
        }
    }","  public void test10()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      cpioArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
}"
"    public void close() throws IOException {
        finish();
        if (raf != null) {
            raf.close();
        }
        if (out != null) {
            out.close();
        }
    }","  public void test22()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      zipArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
}"
"    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ZipArchiveEntry other = (ZipArchiveEntry) obj;
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        return true;
    }","  public void test29()  throws Throwable  {
      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
      ZipArchiveEntry zipArchiveEntry1 = new ZipArchiveEntry(""y"");
      boolean boolean0 = zipArchiveEntry1.equals(zipArchiveEntry0);
      assertFalse(boolean0);
}"
"    public long getBytesWritten() {
        return bytesWritten;
    }","  public void test07()  throws Throwable  {
      File file0 = MockFile.createTempFile(""Ou{e 6;.kh"", ""Ou{e 6;.kh"");
      MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
      TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);
      tarArchiveOutputStream0.close();
      tarArchiveOutputStream0.close();
      assertEquals(10240L, tarArchiveOutputStream0.getBytesWritten());
}"
"    public ZipShort getCentralDirectoryLength() {
        return getLocalFileDataLength();
    }","  public void test04()  throws Throwable  {
      X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
      ZipShort zipShort0 = x7875_NewUnix0.getCentralDirectoryLength();
      assertEquals(0, zipShort0.getValue());
}"
"    public void close() throws IOException {
        if (!finished) {
            finish();
        }
        destroy();
    }","  public void test33()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      zipArchiveOutputStream0.finish();
      zipArchiveOutputStream0.close();
      assertEquals(""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)
            throws IOException {
        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);
        if (hasZip64Extra(ae)) {
            // Will be re-added as required. this may make the file generated with this method
            // somewhat smaller than standard mode,
            // since standard mode is unable to remove the zip 64 header.
            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
        }
        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN
                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN
                && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;
        putArchiveEntry(ae, is2PhaseSource);
        copyFromZipInputStream(rawStream);
        closeCopiedEntry(is2PhaseSource);
    }","  public void test18()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);
      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""AUy(e'"", true);
      zipArchiveOutputStream0.putArchiveEntry(zipArchiveEntry0);
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(""AUy(e'"");
      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);
      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);
      assertEquals(""PK\u0003\u0004\u0014\u0000\b\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0007\b\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDPK\u0003\u0004\u0014\u0000\u0000\b\b\u0000\uFFFD\uFFFDND\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", byteArrayOutputStream0.toString());
}"
"    int readEscape() throws IOException {
        // the escape char has just been read (normally a backslash)
        final int c = in.read();
        switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF: // TODO is this correct?
        case TAB: // TODO is this correct? Do tabs need to be escaped?
        case BACKSPACE: // TODO is this correct?
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
                return c;
            // indicate unexpected char - available from in.getLastChar()
        }
    }","  public void test07()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
      StringReader stringReader0 = new StringReader(""QU,rs$@LR&/"");
      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
      cSVLexer0.readEscape();
      int int0 = cSVLexer0.readEscape();
      assertEquals((-1), int0);
}"
"    int readEscape() throws IOException {
        // the escape char has just been read (normally a backslash)
        final int c = in.read();
        switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF: // TODO is this correct?
        case TAB: // TODO is this correct? Do tabs need to be escaped?
        case BACKSPACE: // TODO is this correct?
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
                return c;
            // indicate unexpected char - available from in.getLastChar()
        }
    }","  public void test10()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""org.apache.commons.csv.CSVLexer"");
      Character character0 = new Character('\'');
      Quote quote0 = Quote.ALL;
      Character character1 = new Character('a');
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, character1, character0, false, true, ""org.apache.commons.csv.CSVLexer"", (String) null, stringArray0);
      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
      cSVLexer0.readEscape();
      int int0 = cSVLexer0.readEscape();
      int int1 = cSVLexer0.readEscape();
      assertEquals((-1), int1);
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test35()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
      CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString("""");
      cSVFormat1.hashCode();
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test11()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('q');
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test33()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      String[] stringArray0 = new String[3];
      stringArray0[1] = ""The header contains a duplicate entry: '"";
      stringArray0[2] = ""c[0TyZhMn}#&:L"";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      cSVFormat1.format(stringArray0);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test40()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      String[] stringArray0 = new String[3];
      stringArray0[1] = ""The header contains a duplicate entry: '"";
      stringArray0[2] = ""c[0TyZhMn}#&:L"";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      String string0 = cSVFormat1.toString();
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test29()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The comment start and the escape character cannot be the same ('"");
      cSVFormat1.equals(cSVFormat0);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public boolean getAllowMissingColumnNames() {
        return allowMissingColumnNames;
    }","  public void test23()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('y');
      boolean boolean0 = cSVFormat0.equals(cSVFormat1);
      assertTrue(cSVFormat1.getAllowMissingColumnNames());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test11()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test02()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      QuoteMode quoteMode0 = QuoteMode.MINIMAL;
      CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
      cSVFormat1.hashCode();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""Delimiter=<"").append(delimiter).append('>');
        if (isEscapeCharacterSet()) {
            sb.append(' ');
            sb.append(""Escape=<"").append(escapeCharacter).append('>');
        }
        if (isQuoteCharacterSet()) {
            sb.append(' ');
            sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
        }
        if (isCommentMarkerSet()) {
            sb.append(' ');
            sb.append(""CommentStart=<"").append(commentMarker).append('>');
        }
        if (isNullStringSet()) {
            sb.append(' ');
            sb.append(""NullString=<"").append(nullString).append('>');
        }
        if (recordSeparator != null) {
            sb.append(' ');
            sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
        }
        if (getIgnoreEmptyLines()) {
            sb.append("" EmptyLines:ignored"");
        }
        if (getIgnoreSurroundingSpaces()) {
            sb.append("" SurroundingSpaces:ignored"");
        }
        if (getIgnoreHeaderCase()) {
            sb.append("" IgnoreHeaderCase:ignored"");
        }
        sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
        if (headerComments != null) {
            sb.append(' ');
            sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
        }
        if (header != null) {
            sb.append(' ');
            sb.append(""Header:"").append(Arrays.toString(header));
        }
        return sb.toString();
    }","  public void test45()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      String string0 = cSVFormat1.toString();
      assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> SkipHeaderRecord:false Header:[]"", string0);
}"
"    public String getNullString() {
        return nullString;
    }","  public void test33()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('$');
      cSVFormat0.equals(cSVFormat1);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test34()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      cSVFormat1.getHeader();
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test25()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      Character character0 = Character.valueOf('8');
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
      CSVFormat cSVFormat2 = cSVFormat1.withEscape('?');
      boolean boolean0 = cSVFormat1.equals(cSVFormat2);
      assertEquals(""\\N"", cSVFormat2.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test21()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVFormat cSVFormat1 = cSVFormat0.withQuote('c');
      boolean boolean0 = cSVFormat0.equals(cSVFormat1);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public String getNullString() {
        return nullString;
    }","  public void test23()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      Character character0 = Character.valueOf('8');
      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
      boolean boolean0 = cSVFormat1.equals(cSVFormat0);
      assertEquals(""\\N"", cSVFormat1.getNullString());
}"
"    public char[] expandCurrentSegment()
    {
        final char[] curr = _currentSegment;
        // Let's grow by 50% by default
        final int len = curr.length;
        // but above intended maximum, slow to increase by 25%
        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));
        return (_currentSegment = Arrays.copyOf(curr, newLen));
    }","  public void test45()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      char[] charArray0 = textBuffer0.getCurrentSegment();
      textBuffer0.expandCurrentSegment(262144);
      char[] charArray1 = textBuffer0.expandCurrentSegment();
      assertEquals(327680, charArray1.length);
}"
"    public int writeValue() {
        // Most likely, object:
        if (_type == TYPE_OBJECT) {
            _gotName = false;
            ++_index;
            return STATUS_OK_AFTER_COLON;
        }

        // Ok, array?
        if (_type == TYPE_ARRAY) {
            int ix = _index;
            ++_index;
            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;
        }
        
        // Nope, root context
        // No commas within root context, but need space
        ++_index;
        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;
    }","  public void test12()  throws Throwable  {
      DupDetector dupDetector0 = DupDetector.rootDetector((JsonParser) null);
      JsonWriteContext jsonWriteContext0 = JsonWriteContext.createRootContext(dupDetector0);
      JsonWriteContext jsonWriteContext1 = jsonWriteContext0.createChildObjectContext();
      int int0 = jsonWriteContext1.writeValue();
      assertEquals(5, int0);
}"
"    public char[] getTextBuffer()
    {
        // Are we just using shared input buffer?
        if (_inputStart >= 0) return _inputBuffer;
        if (_resultArray != null)  return _resultArray;
        if (_resultString != null) {
            return (_resultArray = _resultString.toCharArray());
        }
        // Nope; but does it fit in just one segment?
        if (!_hasSegments)  return _currentSegment;
        // Nope, need to have/create a non-segmented array and return it
        return contentsAsArray();
    }","  public void test27()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithEmpty();
      char[] charArray0 = textBuffer0.getTextBuffer();
      assertNotNull(charArray0);
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test50()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      filteringParserDelegate0._nextToken2();
      boolean boolean0 = filteringParserDelegate0.isExpectedStartArrayToken();
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test43()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      filteringParserDelegate0._nextToken2();
      boolean boolean0 = filteringParserDelegate0.hasTokenId(33);
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public int getMatchCount() {
        return _matchCount;
    }","  public void test67()  throws Throwable  {
      TokenFilter tokenFilter0 = new TokenFilter();
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, false);
      StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$"");
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
      FilteringParserDelegate filteringParserDelegate1 = new FilteringParserDelegate(filteringParserDelegate0, tokenFilter0, false, false);
      filteringParserDelegate0.nextToken();
      filteringParserDelegate1.nextValue();
      assertEquals(1, filteringParserDelegate0.getMatchCount());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test08()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<String> class2 = String.class;
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 1006);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      Class<Error> class3 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class3);
      mapDeserializer0.withResolved(stdKeyDeserializer_StringKD0, (TypeDeserializer) null, mapDeserializer0, linkedHashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test09()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<MapperFeature> class2 = MapperFeature.class;
      CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class2, 10);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, coreXMLDeserializers_Std0, (TypeDeserializer) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      TypeFactory typeFactory0 = TypeFactory.defaultInstance();
      ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
      Class<InputStream> class3 = InputStream.class;
      AsWrapperTypeDeserializer asWrapperTypeDeserializer0 = new AsWrapperTypeDeserializer(collectionLikeType0, classNameIdResolver0, """", false, class3);
      mapDeserializer0.withResolved((KeyDeserializer) null, asWrapperTypeDeserializer0, coreXMLDeserializers_Std0, hashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test07()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class0, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 3980);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      mapDeserializer0.getContentType();
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test02()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      JavaType javaType0 = mapDeserializer0.getValueType();
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test01()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      MapDeserializer mapDeserializer1 = new MapDeserializer(mapDeserializer0);
      assertFalse(mapDeserializer1.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test20()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, simpleType0);
      Class<Integer> class1 = Integer.class;
      StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class1);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, stdKeyDeserializer0, (JsonDeserializer<Object>) null, (TypeDeserializer) null);
      boolean boolean0 = mapDeserializer0.isCachable();
      assertFalse(boolean0);
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test18()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<Error> class2 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);
      boolean boolean0 = mapDeserializer0.isCachable();
      assertFalse(boolean0);
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test15()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.class;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      Class<Error> class2 = Error.class;
      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);
      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);
      BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
      DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
      mapDeserializer0.resolve(defaultDeserializationContext_Impl0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test13()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      String[] stringArray0 = new String[0];
      mapDeserializer0.setIgnorableProperties(stringArray0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test11()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      mapDeserializer0.setIgnorableProperties((String[]) null);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isCachable() {
        /* As per [databind#735], existence of value or key deserializer (only passed
         * if annotated to use non-standard one) should also prevent caching.
         */
        return (_valueTypeDeserializer == null)
                && (_ignorableProperties == null);
    }","  public void test10()  throws Throwable  {
      Class<FilterInputStream> class0 = FilterInputStream.class;
      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
      Class<Integer> class1 = Integer.TYPE;
      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);
      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);
      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);
      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      MapDeserializer mapDeserializer1 = mapDeserializer0.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);
      MapDeserializer mapDeserializer2 = mapDeserializer1.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);
      assertFalse(mapDeserializer0.isCachable());
}"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test14()  throws Throwable  {
      StdDateFormat stdDateFormat0 = StdDateFormat.instance;
      boolean boolean0 = stdDateFormat0.isLenient();
      assertFalse(boolean0);
}"
"    public Object generateId(Object forPojo) {
        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of
        //    id being generated for ""alwaysAsId"", but not being written as POJO; regardless,
        //    need to use existing id if there is one:
            id = generator.generateId(forPojo);
        return id;
    }","  public void test4()  throws Throwable  {
      ObjectIdGenerators.IntSequenceGenerator objectIdGenerators_IntSequenceGenerator0 = new ObjectIdGenerators.IntSequenceGenerator();
      WritableObjectId writableObjectId0 = new WritableObjectId(objectIdGenerators_IntSequenceGenerator0);
      writableObjectId0.generateId(objectIdGenerators_IntSequenceGenerator0);
      Object object0 = new Object();
      Object object1 = writableObjectId0.generateId(object0);
      assertEquals((-1), object1);
}"
"    public String toString()
    {
        return new StringBuilder(40)
            .append(""[reference type, class "")
            .append(buildCanonicalName())
            .append('<')
            .append(_referencedType)
            .append('>')
            .append(']')
            .toString();
    }","  public void test03()  throws Throwable  {
      SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
      ReferenceType referenceType0 = new ReferenceType(simpleType0, simpleType0);
      String string0 = referenceType0.toString();
      assertEquals(""[reference type, class java.lang.Object<java.lang.Object><[simple type, class java.lang.Object]>]"", string0);
}"
"    public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
    {
        if (_classNames.contains(clsName)) {
            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
            if (d != null) {
                return d;
            }
            if (rawType == UUID.class) {
                return new UUIDDeserializer();
            }
            if (rawType == StackTraceElement.class) {
                return new StackTraceElementDeserializer();
            }
            if (rawType == AtomicBoolean.class) {
                // (note: AtomicInteger/Long work due to single-arg constructor. For now?
                return new AtomicBooleanDeserializer();
            }
            if (rawType == ByteBuffer.class) {
                return new ByteBufferDeserializer();
            }
        }
        return null;
    }","  public void test5()  throws Throwable  {
      Class<Void> class0 = Void.class;
      JsonDeserializer<?> jsonDeserializer0 = JdkDeserializers.find(class0, ""com.fasterxml.jackson.databind.JavaType"");
      assertNotNull(jsonDeserializer0);
}"
"    static String escape(String string, Document.OutputSettings out) {
        return escape(string, out.encoder(), out.escapeMode());
    }","  public void test3()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      CharsetEncoder charsetEncoder0 = charset0.newEncoder();
      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.extended;
      String string0 = Entities.escape(""Fo%^]N={*!BXG'NZQ"", charsetEncoder0, entities_EscapeMode0);
      assertEquals(""Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ"", string0);
}"
"    static String unescape(String string) {
        if (!string.contains(""&""))
            return string;

        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs

        while (m.find()) {
            int charval = -1;
            String num = m.group(3);
            if (num != null) {
                try {
                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                    charval = Integer.valueOf(num, base);
                } catch (NumberFormatException e) {
                } // skip
            } else {
                String name = m.group(1).toLowerCase();
                if (full.containsKey(name))
                    charval = full.get(name);
            }

            if (charval != -1 || charval > 0xFFFF) { // out of range
                String c = Character.toString((char) charval);
                m.appendReplacement(accum, c);
            } else {
                m.appendReplacement(accum, m.group(0)); // replace with original string
            }
        }
        m.appendTail(accum);
        return accum.toString();
    }","  public void test4()  throws Throwable  {
      String string0 = Entities.unescape(""Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ"");
      assertEquals(""Fo%^]N={*!BXG'NZQ"", string0);
}"
"    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
        accum.append(""<!DOCTYPE html"");
        if (!StringUtil.isBlank(attr(""publicId"")))
            accum.append("" PUBLIC \"""").append(attr(""publicId"")).append(""\"""");
        if (!StringUtil.isBlank(attr(""systemId"")))
            accum.append(' ').append(attr(""systemId"")).append(""\"""");
        accum.append('>');
    }","  public void test1()  throws Throwable  {
      DocumentType documentType0 = new DocumentType(""ygL0pop.]WM:R$swY0g"", ""ygL0pop.]WM:R$swY0g"", ""ygL0pop.]WM:R$swY0g"", ""s)XlM.FRp.@;D$"");
      Attributes attributes0 = new Attributes();
      documentType0.attributes = attributes0;
      StringBuilder stringBuilder0 = new StringBuilder();
      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
      documentType0.outerHtmlHead(stringBuilder0, 1, document_OutputSettings0);
      assertEquals(""<!DOCTYPE >"", stringBuilder0.toString());
}"
"    public DocumentType(String name, String publicId, String systemId, String baseUri) {
        super(baseUri);

        attr(""name"", name);
        attr(""publicId"", publicId);
        attr(""systemId"", systemId);
    }","  public void test0()  throws Throwable  {
      DocumentType documentType0 = new DocumentType(""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"");
      String string0 = documentType0.outerHtml();
      assertEquals(""<!DOCTYPE /:u'$8-DkwD}/:5 PUBLIC \""/:u'$8-DkwD}/:5\"" \""/:u'$8-DkwD}/:5\"">"", string0);
}"
"    boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
        TagName tag = TagName.valueOf(tagName);
        AttributeKey key = AttributeKey.valueOf(attr.getKey());

        if (attributes.containsKey(tag)) {
            if (attributes.get(tag).contains(key)) {
                if (protocols.containsKey(tag)) {
                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);
                    // ok if not defined protocol; otherwise test
                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));
                } else { // attribute found, no protocols defined, so OK
                    return true;
                }
            }
        } else { // no attributes defined for tag, try :all tag
            return !tagName.equals("":all"") && isSafeAttribute("":all"", el, attr);
        }
        return false;
    }","  public void test10()  throws Throwable  {
      Whitelist whitelist0 = Whitelist.basicWithImages();
      String[] stringArray0 = new String[3];
      stringArray0[0] = ""cite"";
      stringArray0[1] = ""h5WK''"";
      stringArray0[2] = ""h5WK''"";
      Whitelist whitelist1 = whitelist0.addAttributes(""cite"", stringArray0);
      Document document0 = new Document(""h5WK''"");
      Attribute attribute0 = Attribute.createFromEncoded(""cite"", ""http:h5wk''"");
      boolean boolean0 = whitelist1.isSafeAttribute(""cite"", document0, attribute0);
      assertTrue(boolean0);
}"
"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }","  public void test0()  throws Throwable  {
      Whitelist whitelist0 = new Whitelist();
      Cleaner cleaner0 = new Cleaner(whitelist0);
      Document document0 = Document.createShell(""org.jsoup.safeG Cleae$IlanrngVisitor"");
      whitelist0.addEnforcedAttribute(""body"", ""<html>\n <head></head>\n <body></body>\n</html>"", ""org.jsoup.safeG Cleae$IlanrngVisitor"");
      Document document1 = cleaner0.clean(document0);
      boolean boolean0 = cleaner0.isValid(document1);
      assertFalse(boolean0);
}"
"    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        Element element = (Element) o;

        return this == o;
    }","  public void test69()  throws Throwable  {
      Document document0 = new Document(""value"");
      Document document1 = new Document("">5Z"");
      boolean boolean0 = document0.equals(document1);
      assertTrue(boolean0);
}"
"    static String escape(String string, Document.OutputSettings out) {
        StringBuilder accum = new StringBuilder(string.length() * 2);
        escape(accum, string, out, false, false, false);
        return accum.toString();
    }","  public void test10()  throws Throwable  {
      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;
      document_OutputSettings0.escapeMode(entities_EscapeMode0);
      StringBuilder stringBuilder0 = new StringBuilder();
      Entities.escape(stringBuilder0, ""]?`?<DQr@*K"", document_OutputSettings0, true, true, true);
      assertEquals(""]?`?&lt;DQr@*K"", stringBuilder0.toString());
}"
"    public String toString() {
        return outerHtml();
    }","  public void test1()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""t4N7&Q"", ""NW91EkPm "", false);
      String string0 = xmlDeclaration0.toString();
      assertEquals(""<?t4N7&Q?>"", string0);
}"
"    public String getWholeDeclaration() {
        final String decl = this.name;
        if(decl.equals(""xml"") && attributes.size() > 1 ) {
            StringBuilder sb = new StringBuilder(decl);
            final String version = attributes.get(""version"");
            if( version != null ) {
                sb.append("" version=\"""").append(version).append(""\"""");
            }
            final String encoding = attributes.get(""encoding"");
            if( encoding != null ) {
                sb.append("" encoding=\"""").append(encoding).append(""\"""");
            }
            return sb.toString();
        }
        else {
            return this.name;
        }
    }","  public void test2()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""n/(:P!,Rl&n<F63$O"", ""n/(:P!,Rl&n<F63$O"", false);
      String string0 = xmlDeclaration0.getWholeDeclaration();
      assertEquals("""", string0);
}"
"    public String toString() {
        return outerHtml();
    }","  public void test3()  throws Throwable  {
      XmlDeclaration xmlDeclaration0 = new XmlDeclaration("""", """", true);
      String string0 = xmlDeclaration0.toString();
      assertEquals(""<!!>"", string0);
}"
"    public int pos() {
        return readerPos + bufPos;
    }","  public void test31()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""<A)s.2T#T`V"");
      String string0 = characterReader0.consumeTagName();
      assertEquals(0, characterReader0.pos());
}"
"    public String getValue() {
        return val;
    }","  public void test04()  throws Throwable  {
      Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null);
      Attribute attribute1 = attribute0.clone();
      boolean boolean0 = attribute1.equals(attribute0);
      assertEquals("""", attribute1.getValue());
}"
"    public String getValue() {
        return val;
    }","  public void test25()  throws Throwable  {
      Attribute attribute0 = new Attribute(""7b([!ve"", (String) null);
      attribute0.hashCode();
      assertEquals("""", attribute0.getValue());
}"
"    public boolean equals(Object o) { // note parent not considered
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attribute attribute = (Attribute) o;
        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;
        return val != null ? val.equals(attribute.val) : attribute.val == null;
    }","  public void test23()  throws Throwable  {
      Attribute attribute0 = new Attribute(""RG5hzl9})]EB&"", ""RG5hzl9})]EB&"");
      Attribute attribute1 = new Attribute(""RG5hzl9})]EB&"", (String) null);
      boolean boolean0 = attribute1.equals(attribute0);
      assertTrue(attribute0.equals((Object)attribute1));
}"
"    public String getValue() {
        return val;
    }","  public void test20()  throws Throwable  {
      Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null);
      boolean boolean0 = attribute0.equals(attribute0);
      assertEquals("""", attribute0.getValue());
}"
"    public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }","  public void test2()  throws Throwable  {
      Constant constant0 = new Constant(""9|"");
      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual0 = new CoreOperationGreaterThanOrEqual(constant0, constant0);
      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual1 = new CoreOperationGreaterThanOrEqual(coreOperationGreaterThanOrEqual0, constant0);
      Object object0 = coreOperationGreaterThanOrEqual1.computeValue((EvalContext) null);
      assertEquals(false, object0);
}"
"    public boolean testNode(NodeTest test) {
        return testNode(node, test);
    }","  public void test24()  throws Throwable  {
      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();
      Locale locale0 = Locale.FRENCH;
      HTMLTableElementImpl hTMLTableElementImpl0 = new HTMLTableElementImpl(hTMLDocumentImpl0, ""Unknown namespace prefix: "");
      DOMNodePointer dOMNodePointer0 = new DOMNodePointer(hTMLTableElementImpl0, locale0);
      QName qName0 = dOMNodePointer0.getName();
      NodeNameTest nodeNameTest0 = new NodeNameTest(qName0, ""http://www.w3.org/XML/1998/namespace"");
      boolean boolean0 = dOMNodePointer0.testNode((NodeTest) nodeNameTest0);
      assertTrue(boolean0);
}"
"    protected Object functionRound(EvalContext context) {
        assertArgCount(1);
        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
        return new Double(Math.round(v));
    }","  public void test79()  throws Throwable  {
      Constant constant0 = new Constant(""concat"");
      Expression[] expressionArray0 = new Expression[1];
      expressionArray0[0] = (Expression) constant0;
      CoreFunction coreFunction0 = new CoreFunction(7, expressionArray0);
      Object object0 = coreFunction0.functionRound((EvalContext) null);
      assertEquals(Double.NaN, object0);
}"
"    public boolean testNode(NodeTest test) {
        return testNode(this, node, test);
    }","  public void test30()  throws Throwable  {
      QName qName0 = new QName(""[QT~sGq>_#hT|#8m"", ""[QT~sGq>_#hT|#8m"");
      VariablePointer variablePointer0 = new VariablePointer(qName0);
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);
      boolean boolean0 = JDOMNodePointer.testNode((NodePointer) variablePointer0, (Object) null, (NodeTest) nodeTypeTest0);
      assertTrue(boolean0);
}"
"    public String asPath() {
        if (id != null) {
            return ""id('"" + escape(id) + ""')"";
        }

        StringBuffer buffer = new StringBuffer();
        if (parent != null) {
            buffer.append(parent.asPath());
        }
        switch (node.getNodeType()) {
            case Node.ELEMENT_NODE :
                // If the parent pointer is not a DOMNodePointer, it is
                // the parent's responsibility to produce the node test part
                // of the path
                if (parent instanceof DOMNodePointer) {
                    if (buffer.length() == 0
                            || buffer.charAt(buffer.length() - 1) != '/') {
                        buffer.append('/');
                    }
                    String ln = DOMNodePointer.getLocalName(node);
                    String nsURI = getNamespaceURI();
                    if (nsURI == null) {
                        buffer.append(ln);
                        buffer.append('[');
                        buffer.append(getRelativePositionByQName()).append(']');
                    }
                    else {
                        String prefix = getNamespaceResolver().getPrefix(nsURI);
                        if (prefix != null) {
                            buffer.append(prefix);
                            buffer.append(':');
                            buffer.append(ln);
                            buffer.append('[');
                            buffer.append(getRelativePositionByQName());
                            buffer.append(']');
                        }
                        else {
                            buffer.append(""node()"");
                            buffer.append('[');
                            buffer.append(getRelativePositionOfElement());
                            buffer.append(']');
                        }
                    }
                }
            break;
            case Node.TEXT_NODE :
            case Node.CDATA_SECTION_NODE :
                buffer.append(""/text()"");
                buffer.append('[');
                buffer.append(getRelativePositionOfTextNode()).append(']');
                break;
            case Node.PROCESSING_INSTRUCTION_NODE :
                buffer.append(""/processing-instruction(\'"");
                buffer.append(((ProcessingInstruction) node).getTarget()).append(""')"");
                buffer.append('[');
                buffer.append(getRelativePositionOfPI()).append(']');
                break;
            case Node.DOCUMENT_NODE :
                // That'll be empty
                break;
            default:
                break;
        }
        return buffer.toString();
    }","  public void test65()  throws Throwable  {
      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();
      DOMNodePointer dOMNodePointer0 = new DOMNodePointer((NodePointer) null, hTMLDocumentImpl0);
      PSVIDocumentImpl pSVIDocumentImpl0 = new PSVIDocumentImpl();
      Element element0 = pSVIDocumentImpl0.createElementNS("""", ""Factory could not create a child node for path: "", ""xmlns"");
      DOMNodePointer dOMNodePointer1 = new DOMNodePointer(dOMNodePointer0, element0);
      String string0 = dOMNodePointer1.asPath();
      assertEquals(""/xmlns[1]"", string0);
}"
"    public ExtendedMessageFormat(String pattern) {
        this(pattern, Locale.getDefault());
    }","  public void test08()  throws Throwable  {
      ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""*3-"");
      HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
      ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(""*3-"", hashMap0);
      boolean boolean0 = extendedMessageFormat0.equals(extendedMessageFormat1);
      assertFalse(boolean0);
}"
"    public static String getShortClassName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortClassName(object.getClass());
    }","  public void test11()  throws Throwable  {
      String string0 = ClassUtils.getShortClassName(""[LJNM-;"");
      assertEquals(""JNM-[]"", string0);
}"
"    public static String getShortCanonicalName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortCanonicalName(object.getClass().getName());
    }","  public void test12()  throws Throwable  {
      String string0 = ClassUtils.getShortCanonicalName(""["");
      assertEquals(""][]"", string0);
}"
"    public static String getShortClassName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortClassName(object.getClass());
    }","  public void test13()  throws Throwable  {
      String string0 = ClassUtils.getShortClassName(""[[LJNM-"");
      assertEquals(""LJNM-[][]"", string0);
}"
"    public static String getShortCanonicalName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getShortCanonicalName(object.getClass().getName());
    }","  public void test14()  throws Throwable  {
      String string0 = ClassUtils.getShortCanonicalName(""B"");
      assertEquals(""byte"", string0);
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test09()  throws Throwable  {
      String string0 = StringEscapeUtils.escapeJava(""OZw9N)RwzH/"");
      assertEquals(""OZw9N)RwzH/"", string0);
}"
"    public int getDenominator() {
        return denominator;
    }","  public void test28()  throws Throwable  {
      Fraction fraction0 = Fraction.getFraction(0, 394);
      Fraction fraction1 = fraction0.reduce();
      assertEquals(1, fraction1.getDenominator());
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test08()  throws Throwable  {
      String string0 = ""<<\\u+ob%jNBH/"";
      String string1 = StringEscapeUtils.escapeJava(string0);
      assertEquals(""<<\\\\u+ob%jNBH\\/"", string1);
}"
"    public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
    }","  public void test09()  throws Throwable  {
      String string0 = StringEscapeUtils.escapeJava(""3b#H/LYs'XYVNA3|'T"");
      assertEquals(""3b#H\\/LYs'XYVNA3|'T"", string0);
}"
"    public static Date truncate(Date date, int field) {
        if (date == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
        Calendar gval = Calendar.getInstance();
        gval.setTime(date);
        modify(gval, field, false);
        return gval.getTime();
    }","  public void test53()  throws Throwable  {
      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;
      Locale locale0 = Locale.CANADA;
      Calendar calendar0 = MockCalendar.getInstance((TimeZone) zoneInfo0, locale0);
      Calendar calendar1 = DateUtils.truncate(calendar0, 13);
      assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", calendar1.toString());
}"
"    public static Date round(Date date, int field) {
        if (date == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
        Calendar gval = Calendar.getInstance();
        gval.setTime(date);
        modify(gval, field, true);
        return gval.getTime();
    }","  public void test54()  throws Throwable  {
      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
      Date date0 = DateUtils.round((Object) mockGregorianCalendar0, 12);
      assertEquals(""Fri Feb 14 20:21:00 GMT 2014"", date0.toString());
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test4()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(2202.502669393223, 2202.502669393223);
      Logistic logistic0 = new Logistic(2202.502669393223, 2202.502669393223, 596, (-83.763), 596, 596);
      GoalType goalType0 = GoalType.MINIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(596, (UnivariateFunction) logistic0, goalType0, 2.5339783209345245E8, (double) 596, (-2207.0263));
      assertEquals((-2207.0263), univariatePointValuePair0.getPoint(), 0.01);
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test7()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(1972.9354295246733, 1973.80211594);
      Gaussian gaussian0 = new Gaussian(2047, 2047);
      GoalType goalType0 = GoalType.MAXIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(1560, (UnivariateFunction) gaussian0, goalType0, (-1.9872713979884691E43), 0.06666666666666667, 0.06666666666666667);
      assertEquals(0.06666666666666667, univariatePointValuePair0.getPoint(), 0.01);
}"
"    public BrentOptimizer(double rel,
                          double abs,
                          ConvergenceChecker<UnivariatePointValuePair> checker) {
        super(checker);

        if (rel < MIN_RELATIVE_TOLERANCE) {
            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);
        }
        if (abs <= 0) {
            throw new NotStrictlyPositiveException(abs);
        }

        relativeThreshold = rel;
        absoluteThreshold = abs;
    }","  public void test6()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer(5.8015881615938497E-8, 5.8015881615938497E-8);
      Signum signum0 = new Signum();
      GoalType goalType0 = GoalType.MAXIMIZE;
      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(2146396205, (UnivariateFunction) signum0, goalType0, 0.5469118054664329, 0.5469118054664329, 1.9017692579836876E-4);
      assertEquals(1.9017692579836876E-4, univariatePointValuePair0.getPoint(), 0.01);
}"
"    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
        clearResult();
        return localMin(getGoalType() == GoalType.MINIMIZE,
                        f, goalType, min, startValue, max,
                        getRelativeAccuracy(), getAbsoluteAccuracy());
    }","  public void test4()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer();
      double[] doubleArray0 = new double[8];
      doubleArray0[5] = Double.NaN;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      GoalType goalType0 = GoalType.MINIMIZE;
      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, 0.0, (-874.0), (-4351.645960419921));
      assertEquals(21, brentOptimizer0.getIterationCount());
}"
"    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
        clearResult();
        return localMin(getGoalType() == GoalType.MINIMIZE,
                        f, goalType, min, startValue, max,
                        getRelativeAccuracy(), getAbsoluteAccuracy());
    }","  public void test2()  throws Throwable  {
      BrentOptimizer brentOptimizer0 = new BrentOptimizer();
      double[] doubleArray0 = new double[8];
      doubleArray0[2] = (-873.217716);
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      GoalType goalType0 = GoalType.MAXIMIZE;
      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, (-873.217716), 0.0, (-1.0));
      assertEquals(56, brentOptimizer0.getEvaluations());
}"
"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }","  public void test4()  throws Throwable  {
      FDistributionImpl fDistributionImpl0 = new FDistributionImpl(763.683107623722, 1225.931330739);
      fDistributionImpl0.setDenominatorDegreesOfFreedom(1.0);
      double double0 = fDistributionImpl0.getInitialDomain((-942.0));
      assertEquals(1.0, double0, 0.01);
}"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test39()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      String string0 = jsonReader0.nextString();
      assertEquals(""1"", string0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(string0);
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test41()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""FALSE"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      boolean boolean0 = jsonReader0.nextBoolean();
      assertFalse(boolean0);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test42()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""NULL"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      JsonToken jsonToken0 = jsonReader0.peek();
      assertEquals(JsonToken.NULL, jsonToken0);
      assertFalse(jsonReader0.isLenient());
      
      jsonReader0.nextNull();
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test45()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      double double0 = jsonReader0.nextDouble();
      assertEquals(1.0, double0, 0.01);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test49()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      long long0 = jsonReader0.nextLong();
      assertEquals(1L, long0);
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test68()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""1[Is\""A\""vL&"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.skipValue();
      assertFalse(jsonReader0.isLenient());
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test18()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(""java.lang#Float@0000000003"");
      assertTrue(jsonWriter1.getSerializeNulls());
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test20()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      JsonWriter jsonWriter1 = jsonWriter0.value(true);
      jsonWriter1.close();
      jsonWriter1.close();
      assertEquals(""true"", stringWriter0.toString());
      assertTrue(jsonWriter0.getSerializeNulls());
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test59()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""464D"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.setLenient(true);
      assertTrue(jsonReader0.isLenient());
      
      long long0 = jsonReader0.nextLong();
      assertTrue(jsonReader0.isLenient());
      assertEquals(464L, long0);
  }"
"  public final boolean isLenient() {
    return lenient;
  }","  public void test76()  throws Throwable  {
      StringReader stringReader0 = new StringReader(""464D"");
      assertNotNull(stringReader0);
      
      JsonReader jsonReader0 = new JsonReader(stringReader0);
      assertFalse(jsonReader0.isLenient());
      assertNotNull(jsonReader0);
      
      jsonReader0.setLenient(true);
      assertTrue(jsonReader0.isLenient());
      
      int int0 = jsonReader0.nextInt();
      assertTrue(jsonReader0.isLenient());
      assertEquals(464, int0);
      
      jsonReader0.skipValue();
      assertTrue(jsonReader0.isLenient());
  }"
"  @Override public JsonWriter value(String value) throws IOException {
    if (value == null) {
      return nullValue();
    }
    put(new JsonPrimitive(value));
    return this;
  }","  public void test25()  throws Throwable  {
      JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();
      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);
      assertSame(jsonTreeWriter0, jsonWriter0);
  }"
"  public final boolean getSerializeNulls() {
    return serializeNulls;
  }","  public void test25()  throws Throwable  {
      StringWriter stringWriter0 = new StringWriter();
      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);
      jsonWriter0.value((Boolean) null);
      assertEquals(""null"", stringWriter0.toString());
      assertTrue(jsonWriter0.getSerializeNulls());
  }"
"    public int getIndex() {
        return index;
    }","  public void test48()  throws Throwable  {
      QName qName0 = new QName("""");
      VariablePointer variablePointer0 = new VariablePointer(qName0);
      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);
      BasicVariables basicVariables0 = new BasicVariables();
      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);
      int int0 = nodePointer0.compareTo(variablePointer1);
      assertEquals(1, int0);
      assertEquals(Integer.MIN_VALUE, variablePointer1.getIndex());
  }"
"    protected boolean equal(
        EvalContext context,
        Expression left,
        Expression right) 
    {
        Object l = left.compute(context);
        Object r = right.compute(context);

//        System.err.println(""COMPARING: "" +
//            (l == null ? ""null"" : l.getClass().getName()) + "" "" +
//            (r == null ? ""null"" : r.getClass().getName()));

        if (l instanceof InitialContext || l instanceof SelfContext) {
            l = ((EvalContext) l).getSingleNodePointer();
        }

        if (r instanceof InitialContext || r instanceof SelfContext) {
            r = ((EvalContext) r).getSingleNodePointer();
        }

        if (l instanceof Collection) {
            l = ((Collection) l).iterator();
        }

        if (r instanceof Collection) {
            r = ((Collection) r).iterator();
        }

        if ((l instanceof Iterator) && !(r instanceof Iterator)) {
            return contains((Iterator) l, r);
        }
        if (!(l instanceof Iterator) && (r instanceof Iterator)) {
            return contains((Iterator) r, l);
        }
        if (l instanceof Iterator && r instanceof Iterator) {
            return findMatch((Iterator) l, (Iterator) r);
        }
        return equal(l, r);
    }","  public void test02()  throws Throwable  {
      QName qName0 = new QName("""", """");
      VariableReference variableReference0 = new VariableReference(qName0);
      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);
      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);
      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);
      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);
      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);
      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);
      assertFalse(boolean0);
  }"
"    public boolean setPosition(int position) {
        if (position < getCurrentPosition()) {
            reset();
        }

        while (getCurrentPosition() < position) {
            if (!nextNode()) {
                return false;
            }
        }
        return true;
    }","  public void test4()  throws Throwable  {
      BasicNodeSet basicNodeSet0 = new BasicNodeSet();
      NodeSetContext nodeSetContext0 = new NodeSetContext((EvalContext) null, basicNodeSet0);
      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);
      ChildContext childContext0 = new ChildContext(nodeSetContext0, nodeTypeTest0, true, true);
      AttributeContext attributeContext0 = new AttributeContext(childContext0, nodeTypeTest0);
      // Undeclared exception!
      try { 
        attributeContext0.setPosition(1);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.jxpath.ri.axes.AttributeContext"", e);
      }
  }"
"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }","  public void test0()  throws Throwable  {
      LinkedList<Chromosome> linkedList0 = new LinkedList<Chromosome>();
      ElitisticListPopulation elitisticListPopulation0 = null;
      try {
        elitisticListPopulation0 = new ElitisticListPopulation(linkedList0, 2144375856, 2144375856);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // elitism rate (2,144,375,856)
         //
         verifyException(""org.apache.commons.math3.genetics.ElitisticListPopulation"", e);
      }
  }"
"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }","  public void test2()  throws Throwable  {
      ElitisticListPopulation elitisticListPopulation0 = null;
      try {
        elitisticListPopulation0 = new ElitisticListPopulation(1905, (-146.889688));
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // elitism rate (-146.89)
         //
         verifyException(""org.apache.commons.math3.genetics.ElitisticListPopulation"", e);
      }
  }"
"    public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }","  public void test3()  throws Throwable  {
      OpenMapRealMatrix openMapRealMatrix0 = null;
      try {
        openMapRealMatrix0 = new OpenMapRealMatrix(2141034748, Integer.MAX_VALUE);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // 4,597,837,108,988,765,956 is larger than, or equal to, the maximum (2,147,483,647)
         //
         verifyException(""org.apache.commons.math.linear.OpenMapRealMatrix"", e);
      }
  }"
"    public static double[] bracket(UnivariateRealFunction function, 
            double initial, double lowerBound, double upperBound) 
    throws ConvergenceException, FunctionEvaluationException {
        return bracket( function, initial, lowerBound, upperBound,
            Integer.MAX_VALUE ) ;
    }","  public void test07()  throws Throwable  {
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 4037.4646;
      doubleArray0[1] = 283.42488442;
      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);
      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);
      assertArrayEquals(new double[] {0.0, 938.1475384}, doubleArray1, 0.01);
  }"
"    public static int lcm(int a, int b) {
        return Math.abs(mulAndCheck(a / gcd(a, b), b));
    }","  public void test002()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.lcm(1073741824, (-1216));
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: mul
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public static int subAndCheck(int x, int y) {
        long s = (long)x - (long)y;
        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
            throw new ArithmeticException(""overflow: subtract"");
        }
        return (int)s;
    }","  public void test116()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.subAndCheck(0L, (-9223372036854775553L));
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: subtract
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public static int gcd(final int p, final int q) {
        int u = p;
        int v = q;
        if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","  public void test061()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.gcd(Integer.MIN_VALUE, 0);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: gcd(-2,147,483,648, 0) is 2^31
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public static int gcd(final int p, final int q) {
        int u = p;
        int v = q;
        if ((u == 0) || (v == 0)) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","  public void test062()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.gcd(0, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: gcd(0, -2,147,483,648) is 2^31
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public static int lcm(int a, int b) {
        if (a==0 || b==0){
            return 0;
        }
        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
        return lcm;
    }","  public void test081()  throws Throwable  {
      // Undeclared exception!
      try { 
        MathUtils.lcm(4, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
      
      } catch(ArithmeticException e) {
         //
         // overflow: lcm is 2^31
         //
         verifyException(""org.apache.commons.math.util.MathUtils"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test10()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn((-93.275), 0.0, 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      double[] doubleArray0 = new double[1];
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, true);
      dummyStepInterpolator0.storeTime((-3131.738));
      EventState eventState0 = new EventState(eventHandler0, 1028, 1028, 1028);
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, \uFFFD], Values: [-93.275, -93.275]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test14()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn((-1559.2660314847587), 0.0, 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      double[] doubleArray0 = new double[1];
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, false);
      EventState eventState0 = new EventState(eventHandler0, 2688.0509, 1142.904, (-1789569706));
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, \uFFFD], Values: [-1,559.266, -1,559.266]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                if (g0Positive ^ (gb >= 0)) {
                    // there is a sign change: an event is expected during this step

                        // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","  public void test17()  throws Throwable  {
      EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
      doReturn(1.0E-14, 1.0E-14, 1.0E-15, (-2137.64997125), 0.0).when(eventHandler0).g(anyDouble() , any(double[].class));
      EventState eventState0 = new EventState(eventHandler0, (-929.39279781), (-929.39279781), (-243));
      double[] doubleArray0 = new double[3];
      eventState0.stepAccepted((-243.0), doubleArray0);
      eventState0.stepAccepted((-929.39279781), doubleArray0);
      eventState0.stepAccepted(0.0, doubleArray0);
      DummyStepInterpolator dummyStepInterpolator0 = new DummyStepInterpolator(doubleArray0, true);
      // Undeclared exception!
      try { 
        eventState0.evaluateStep(dummyStepInterpolator0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // function values at endpoints do not have different signs.  Endpoints: [\uFFFD, 0], Values: [-2,137.65, -2,137.65]
         //
         verifyException(""org.apache.commons.math.MathRuntimeException"", e);
      }
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test00()  throws Throwable  {
      double[] doubleArray0 = new double[6];
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);
      assertEquals((-1689.2658367652516), double0, 0.01);
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test08()  throws Throwable  {
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 1.0E-14;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      brentSolver0.setFunctionValueAccuracy(1.0E-14);
      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);
      assertEquals((-859.8904), double0, 0.01);
  }"
"    public double solve(double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        if (((initial - min) * (max -initial)) < 0) {
            throw new IllegalArgumentException(""Initial guess is not in search"" +
                      "" interval."" + ""  Initial: "" + initial +
                      ""  Endpoints: ["" + min + "","" + max + ""]"");
        }

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(initial, yInitial, max, yMax, initial, yInitial);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(min, yMin, max, yMax, initial, yInitial);

    }","  public void test09()  throws Throwable  {
      double[] doubleArray0 = new double[5];
      doubleArray0[2] = 1.0E-14;
      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);
      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);
      double double0 = brentSolver0.solve((-1.0), 1.0E-14);
      assertEquals(1.0E-14, double0, 0.01);
  }"
"    public void printWrapped(PrintWriter pw, int width, String text)
    {
        printWrapped(pw, width, 0, text);
    }","  public void test28()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""arg"");
      helpFormatter0.printWrapped((PrintWriter) mockPrintWriter0, 0, ""[ Options: [ short "");
  }"
"    public void printUsage(PrintWriter pw, int width, String app, Options options)
    {
        // initialise the string buffer
        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append("" "");

        // create a list for processed option groups
        final Collection processedGroups = new ArrayList();

        // temp variable
        Option option;

        List optList = new ArrayList(options.getOptions());
        Collections.sort(optList, getOptionComparator());
        // iterate over the options
        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            // get the next Option
            option = (Option) i.next();

            // check if the option is part of an OptionGroup
            OptionGroup group = options.getOptionGroup(option);

            // if the option is part of a group 
            if (group != null)
            {
                // and if the group has not already been processed
                if (!processedGroups.contains(group))
                {
                    // add the group to the processed list
                    processedGroups.add(group);


                    // add the usage clause
                    appendOptionGroup(buff, group);
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
                appendOption(buff, option, option.isRequired());
            }

            if (i.hasNext())
            {
                buff.append("" "");
            }
        }


        // call printWrapped
        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());
    }","  public void test32()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""opt contains illegal character value '"");
      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, ""opt contains illegal character value '"");
      assertEquals(74, helpFormatter0.defaultWidth);
  }"
"    public static Object createValue(final String str, final Object obj) throws ParseException
    {
        return createValue(str, (Class<?>) obj);
    }","  public void test10()  throws Throwable  {
      Class<Integer> class0 = Integer.class;
      try { 
        TypeHandler.createValue(""uo7{tEV1yjof"", class0);
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // Unable to handle the class: class java.lang.Integer
         //
         verifyException(""org.apache.commons.cli.TypeHandler"", e);
      }
  }"
"    static String stripLeadingHyphens(String str)
    {
        if (str.startsWith(""--""))
        {
            return str.substring(2, str.length());
        }
        else if (str.startsWith(""-""))
        {
            return str.substring(1, str.length());
        }

        return str;
    }","  public void test2()  throws Throwable  {
      String string0 = Util.stripLeadingHyphens((String) null);
      assertNull(string0);
  }"
"    public void printUsage(PrintWriter pw, int width, String app, 
                           Options options)
    {
        // initialise the string buffer
        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)
                                                                 .append("" "");

        // create a list for processed option groups
        final Collection processedGroups = new ArrayList();

        // temp variable
        Option option;

        List optList = new ArrayList(options.getOptions());
        Collections.sort(optList, new OptionComparator());
        // iterate over the options
        for (Iterator i = optList.iterator(); i.hasNext();)
        {
            // get the next Option
            option = (Option) i.next();

            // check if the option is part of an OptionGroup
            OptionGroup group = options.getOptionGroup(option);

            // if the option is part of a group 
            if (group != null)
            {
                // and if the group has not already been processed
                if (!processedGroups.contains(group))
                {
                    // add the group to the processed list
                    processedGroups.add(group);


                    // add the usage clause
                    appendOptionGroup(buff, group);
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
                appendOption(buff, option, option.isRequired());
            }

            if (i.hasNext())
            {
                buff.append("" "");
            }
        }


        // call printWrapped
        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, 
                     buff.toString());
    }","  public void test27()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""-"");
      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 0, ""[ Options: [ sh6ort "");
  }"
"    public String getLongOptPrefix()
    {
        return defaultLongOptPrefix;
    }","  public void test24()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      Options options0 = new Options();
      helpFormatter0.printHelp(2, ""\n"", ""\n"", options0, ""6i4?l"");
      assertEquals(""--"", helpFormatter0.getLongOptPrefix());
  }"
"    public void printHelp(String cmdLineSyntax, Options options)
    {
        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);
    }","  public void test25()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      Options options0 = new Options();
      helpFormatter0.printHelp(2, ""-<e6=M|IgIm9wEy]?Rk"", "" "", options0, "" "");
      assertEquals(74, helpFormatter0.defaultWidth);
      assertEquals(3, helpFormatter0.defaultDescPad);
  }"
"    public void printHelp(String cmdLineSyntax, Options options)
    {
        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);
    }","  public void test29()  throws Throwable  {
      HelpFormatter helpFormatter0 = new HelpFormatter();
      assertEquals(3, helpFormatter0.defaultDescPad);
      assertEquals(3, HelpFormatter.DEFAULT_DESC_PAD);
      assertEquals(1, helpFormatter0.defaultLeftPad);
      assertEquals(74, HelpFormatter.DEFAULT_WIDTH);
      assertEquals(1, HelpFormatter.DEFAULT_LEFT_PAD);
      assertEquals(74, helpFormatter0.defaultWidth);
      assertEquals(""--"", helpFormatter0.getLongOptPrefix());
      assertEquals(""\n"", helpFormatter0.getNewLine());
      assertEquals(""arg"", helpFormatter0.getArgName());
      assertEquals(74, helpFormatter0.getWidth());
      assertEquals(1, helpFormatter0.getLeftPadding());
      assertEquals(""-"", helpFormatter0.getOptPrefix());
      assertEquals(""usage: "", helpFormatter0.getSyntaxPrefix());
      assertEquals(3, helpFormatter0.getDescPadding());
      assertNotNull(helpFormatter0);
      
      Options options0 = new Options();
      assertNotNull(options0);
      
      helpFormatter0.printHelp(1, ""\n"", ""arg"", options0, ""--"");
  }"
"    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo

                if (!options.hasOption(opt))
                {
                    processNonOptionToken(token);
                }
                else
                {
                    
                    tokens.add(opt);
                    if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","  public void test1()  throws Throwable  {
      PosixParser posixParser0 = new PosixParser();
      Options options0 = new Options();
      String[] stringArray0 = new String[6];
      stringArray0[0] = ""-PE---"";
      stringArray0[1] = """";
      stringArray0[2] = """";
      stringArray0[3] = ""A CloneNotSupportedExceptionwas thown: "";
      stringArray0[4] = ""--eA_{'~R[w=`"";
      // Undeclared exception!
      try { 
        posixParser0.flatten(options0, stringArray0, false);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
      }
  }"
"    public CSVFormat withHeader(final String... header) {
        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,
                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);
    }","  public void test12()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.TDF;
      String[] stringArray0 = new String[4];
      // Undeclared exception!
      try { 
        cSVFormat0.DEFAULT.withHeader(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // The header contains a duplicate entry: 'null' in [null, null, null, null]
         //
         verifyException(""org.apache.commons.csv.CSVFormat"", e);
      }
  }"
"    public void print(final Object value) throws IOException {
        // null values are considered empty
        String strValue;
        if (value == null) {
            final String nullString = format.getNullString();
            strValue = nullString == null ? Constants.EMPTY : nullString;
        } else {
            strValue = value.toString();
        }
        this.print(value, strValue, 0, strValue.length());
    }","  public void test09()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.TDF;
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      Quote quote0 = Quote.NON_NUMERIC;
      CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
      PipedWriter pipedWriter0 = new PipedWriter();
      try { 
        cSVFormat2.print(pipedWriter0);
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Pipe not connected
         //
         verifyException(""java.io.PipedWriter"", e);
      }
  }"
"    public long getRecordNumber() {
        return recordNumber;
    }","  public void test17()  throws Throwable  {
      HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
      Integer integer0 = new Integer(854);
      hashMap0.put((String) null, integer0);
      String[] stringArray0 = new String[0];
      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);
      cSVRecord0.toMap();
      assertEquals(854L, cSVRecord0.getRecordNumber());
  }"
"    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {
        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);
    }","  public void test5()  throws Throwable  {
      NameType nameType0 = NameType.SEPHARDIC;
      RuleType ruleType0 = RuleType.EXACT;
      PhoneticEngine phoneticEngine0 = null;
      try {
        phoneticEngine0 = new PhoneticEngine(nameType0, ruleType0, true);
        fail(""Expecting exception: NoClassDefFoundError"");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class org.apache.commons.codec.language.bm.Lang
         //
         verifyException(""org.apache.commons.codec.language.bm.PhoneticEngine"", e);
      }
  }"
"    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
        if (bytes == null) {
            return null;
        }
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        for (int i = 0; i < bytes.length; i++) {
            final int b = bytes[i];
            if (b == ESCAPE_CHAR) {
                try {
                    // if the next octet is a CR we have found a soft line break
                    int u = Utils.digit16(bytes[++i]);
                    int l = Utils.digit16(bytes[++i]);
                    buffer.write((char) ((u << 4) + l));
                } catch (ArrayIndexOutOfBoundsException e) {
                    throw new DecoderException(""Invalid quoted-printable encoding"", e);
                }
            } else {
                // every other octet is appended except for CR & LF
                buffer.write(b);
            }
        }
        return buffer.toByteArray();
    }","  public void test09()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)61;
      byteArray0[1] = (byte)13;
      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);
      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0}, byteArray1);
  }"
"    public Base64() {
        this(false);
    }","  public void test00()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test01()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test02()  throws Throwable  {
      byte[] byteArray0 = new byte[17];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test03()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[12];
      // Undeclared exception!
      try { 
        Base64.encodeBase64Chunked(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test05()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test06()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test07()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((byte)1);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test08()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64((byte) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test09()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test11()  throws Throwable  {
      BigInteger bigInteger0 = BigInteger.TEN;
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[18];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test13()  throws Throwable  {
      byte[] byteArray0 = new byte[28];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test14()  throws Throwable  {
      byte[] byteArray0 = new byte[12];
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte) (-1);
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeInteger(BigInteger bigInt) {
        if(bigInt == null)  {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)40;
      BigInteger bigInteger0 = new BigInteger(byteArray0);
      // Undeclared exception!
      try { 
        Base64.encodeInteger(bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test17()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test18()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[10];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] decodeBase64(byte[] base64Data) {
        if (base64Data == null || base64Data.length == 0) {
            return base64Data;
        }
        Base64 b64 = new Base64();
        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.
        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }","  public void test20()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)83;
      // Undeclared exception!
      try { 
        Base64.decodeBase64(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test21()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, false, false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }","  public void test24()  throws Throwable  {
      byte[] byteArray0 = new byte[18];
      // Undeclared exception!
      try { 
        Base64.encodeBase64(byteArray0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test25()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64(false);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test28()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public Base64() {
        this(false);
    }","  public void test35()  throws Throwable  {
      Base64 base64_0 = null;
      try {
        base64_0 = new Base64();
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // lineSeperator must not contain base64 characters: [S\u0000]
         //
         verifyException(""org.apache.commons.codec.binary.Base64"", e);
      }
  }"
"    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
        if (cs1 == null || cs2 == null) {
            return false;
        }
        if (cs1 instanceof String && cs2 instanceof String) {
            return cs1.equals(cs2);
        }
        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
    }","  public void test19()  throws Throwable  {
      char[] charArray0 = new char[0];
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) ""\uFFFD"");
      assertFalse(boolean0);
  }"
"    public String nodeName() {
        return ""#comment"";
    }","  public void test6()  throws Throwable  {
      Comment comment0 = new Comment(""')GQz^]r=Tof"");
      comment0.asXmlDeclaration();
      assertEquals(""#comment"", comment0.nodeName());
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test07()  throws Throwable  {
      Attribute attribute0 = new Attribute(""6xZW/$Zc"", ""6xZW/$Zc"");
      attribute0.setValue((String) null);
      Attribute attribute1 = attribute0.clone();
      boolean boolean0 = attribute0.equals(attribute1);
      assertEquals("""", attribute0.getValue());
      assertTrue(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test18()  throws Throwable  {
      Attribute attribute0 = Attribute.createFromEncoded(""9"", ""9"");
      attribute0.setValue((String) null);
      boolean boolean0 = attribute0.isBooleanAttribute();
      assertEquals("""", attribute0.getValue());
      assertTrue(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test24()  throws Throwable  {
      Attribute attribute0 = Attribute.createFromEncoded(""9"", ""9"");
      Attribute attribute1 = attribute0.clone();
      attribute1.setValue((String) null);
      boolean boolean0 = attribute1.equals(attribute0);
      assertEquals("""", attribute1.getValue());
      assertFalse(boolean0);
  }"
"    public String getValue() {
        return Attributes.checkNotNull(val);
    }","  public void test26()  throws Throwable  {
      Attribute attribute0 = new Attribute(""6xZW/$Zc"", ""6xZW/$Zc"");
      attribute0.setValue((String) null);
      attribute0.hashCode();
      assertEquals("""", attribute0.getValue());
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return accum.toString().trim();
    }","  public void test05()  throws Throwable  {
      Document document0 = new Document(""\""t(OU7Y?U9,'+GS9J@"");
      // Undeclared exception!
      try { 
        document0.html(""\""t(OU7Y?U9,'+GS9J@"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test08()  throws Throwable  {
      Element element0 = new Element(""org.jsoup.selectaluator$IsNthChild"");
      // Undeclared exception!
      try { 
        element0.html(""5;re4BBw,KJ+`!_K"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test74()  throws Throwable  {
      Element element0 = new Element(""textarea"");
      Element element1 = element0.prependElement(""textarea"");
      element1.val(""w.|^4]N&"");
      // Undeclared exception!
      try { 
        element0.html();
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    static String getCharsetFromContentType(String contentType) {
        if (contentType == null) return null;
        Matcher m = charsetPattern.matcher(contentType);
        if (m.find()) {
            String charset = m.group(1).trim();
                if (Charset.isSupported(charset)) return charset;
                charset = charset.toUpperCase(Locale.ENGLISH);
                if (Charset.isSupported(charset)) return charset;
                // if our advanced charset matching fails.... we just take the default
        }
        return null;
    }","  public void test13()  throws Throwable  {
      String string0 = DataUtil.getCharsetFromContentType(""charset="");
      assertNull(string0);
  }"
"    public String toString() {
        return outerHtml();
    }","  public void test08()  throws Throwable  {
      DataNode dataNode0 = DataNode.createFromEncoded(""Y3RuM2Iw}~sa=Np}"", """");
      String string0 = dataNode0.toString();
      assertEquals(""Y3RuM2Iw}~sa=Np}"", string0);
  }"
"    public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        final String out = (end >= 0) ? queue.substring(start, end) : """";
        return out;
    }
    
    /**
     * Unescaped a \ escaped string.
     * @param in backslash escaped string
     * @return unescaped string
     */
    public static String unescape(String in) {
        StringBuilder out = new StringBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == ESC) {
                if (last != 0 && last == ESC)
                    out.append(c);
            }
            else 
                out.append(c);
            last = c;
        }
        return out.toString();
    }

    /**
     * Pulls the next run of whitespace characters of the queue.
     * @return Whether consuming whitespace or not
     */
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            pos++;
            seen = true;
        }
        return seen;
    }

    /**
     * Retrieves the next run of word type (letter or digit) off the queue.
     * @return String of word characters from queue, or empty string if none.
     */
    public String consumeWord() {
        int start = pos;
        while (matchesWord())
            pos++;
        return queue.substring(start, pos);
    }
    
    /**
     * Consume an tag name off the queue (word or :, _, -)
     * 
     * @return tag name
     */
    public String consumeTagName() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))
            pos++;
        
        return queue.substring(start, pos);
    }
    
    /**
     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
     * 
     * @return tag name
     */
    public String consumeElementSelector() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(""*|"",""|"", ""_"", ""-"")))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
     @return identifier
     */
    public String consumeCssIdentifier() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))
            pos++;

        return queue.substring(start, pos);
    }

    /**
     Consume an attribute key off the queue (letter, digit, -, _, :"")
     @return attribute key
     */
    public String consumeAttributeKey() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume and return whatever is left on the queue.
     @return remained of queue.
     */
    public String remainder() {
        final String remainder = queue.substring(pos, queue.length());
        pos = queue.length();
        return remainder;
    }
    
    @Override
    public String toString() {
        return queue.substring(pos);
    }
}
","  public void test05()  throws Throwable  {
      TokenQueue tokenQueue0 = new TokenQueue(""'N7N;gmEL"");
      // Undeclared exception!
      try { 
        tokenQueue0.chompBalanced('\'', '\'');
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Did not find balanced maker at N7N;gmEL
         //
         verifyException(""org.jsoup.helper.Validate"", e);
      }
  }"
"    public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        final String out = (end >= 0) ? queue.substring(start, end) : """";
        return out;
    }
    
    /**
     * Unescaped a \ escaped string.
     * @param in backslash escaped string
     * @return unescaped string
     */
    public static String unescape(String in) {
        StringBuilder out = new StringBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == ESC) {
                if (last != 0 && last == ESC)
                    out.append(c);
            }
            else 
                out.append(c);
            last = c;
        }
        return out.toString();
    }

    /**
     * Pulls the next run of whitespace characters of the queue.
     * @return Whether consuming whitespace or not
     */
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            pos++;
            seen = true;
        }
        return seen;
    }

    /**
     * Retrieves the next run of word type (letter or digit) off the queue.
     * @return String of word characters from queue, or empty string if none.
     */
    public String consumeWord() {
        int start = pos;
        while (matchesWord())
            pos++;
        return queue.substring(start, pos);
    }
    
    /**
     * Consume an tag name off the queue (word or :, _, -)
     * 
     * @return tag name
     */
    public String consumeTagName() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))
            pos++;
        
        return queue.substring(start, pos);
    }
    
    /**
     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
     * 
     * @return tag name
     */
    public String consumeElementSelector() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(""*|"",""|"", ""_"", ""-"")))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
     @return identifier
     */
    public String consumeCssIdentifier() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))
            pos++;

        return queue.substring(start, pos);
    }

    /**
     Consume an attribute key off the queue (letter, digit, -, _, :"")
     @return attribute key
     */
    public String consumeAttributeKey() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume and return whatever is left on the queue.
     @return remained of queue.
     */
    public String remainder() {
        final String remainder = queue.substring(pos, queue.length());
        pos = queue.length();
        return remainder;
    }
    
    @Override
    public String toString() {
        return queue.substring(pos);
    }
}
","  public void test24()  throws Throwable  {
      TokenQueue tokenQueue0 = new TokenQueue(""heCIIhcb$o"");
      assertFalse(tokenQueue0.isEmpty());
      assertTrue(tokenQueue0.matchesWord());
      assertFalse(tokenQueue0.matchesStartTag());
      assertEquals(""heCIIhcb$o"", tokenQueue0.toString());
      assertEquals('h', tokenQueue0.peek());
      assertNotNull(tokenQueue0);
      
      // Undeclared exception!
      try { 
        tokenQueue0.chompBalanced('h', 'h');
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Did not find balanced maker at eCIIhcb$o
         //
         verifyException(""org.jsoup.helper.Validate"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test37()  throws Throwable  {
      Document document0 = new Document(""br"");
      document0.appendChild(document0);
      // Undeclared exception!
      try { 
        document0.html(""br"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum); 
        return accum.toString().trim();
    }","  public void test06()  throws Throwable  {
      Document document0 = new Document(""d|kN/6:H"");
      // Undeclared exception!
      try { 
        document0.html(""JKjy$]SO>hwwo?|"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    boolean containsIgnoreCase(String seq) {
        // used to check presence of </title>, </style>. only finds consistent case.
        String loScan = seq.toLowerCase(Locale.ENGLISH);
        String hiScan = seq.toUpperCase(Locale.ENGLISH);
        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);
    }","  public void test12()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""8Kr':%(6-\""p@8&Z_$8"");
      boolean boolean0 = characterReader0.containsIgnoreCase(""8Kr':%(6-\""p@8&Z_$8"");
      assertFalse(boolean0);
  }"
"    public Document clean(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
            copySafeNodes(dirtyDocument.body(), clean.body());

        return clean;
    }","  public void test0()  throws Throwable  {
      Whitelist whitelist0 = Whitelist.basicWithImages();
      Cleaner cleaner0 = new Cleaner(whitelist0);
      Document document0 = new Document("")}IYN&vF+R/bSRCs bc"");
      Document document1 = cleaner0.clean(document0);
      assertNotSame(document1, document0);
  }"
"    public String html() {
        StringBuilder accum = new StringBuilder();
        html(accum);
        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
    }","  public void test07()  throws Throwable  {
      Document document0 = new Document(""rn<y!,}g<6vpwvpjc`"");
      // Undeclared exception!
      try { 
        document0.html(""aSBR%LKA-{"");
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.LinkedList"", e);
      }
  }"
"    public String toString() {
        return input.substring(pos);
    }","  public void test14()  throws Throwable  {
      CharacterReader characterReader0 = new CharacterReader(""J"");
      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(""J"");
      assertTrue(boolean0);
      
      characterReader0.consumeTo('J');
      assertEquals("""", characterReader0.toString());
  }"
"    public static long parseOctalOrBinary(final byte[] buffer, final int offset,
                                          final int length) {

        if ((buffer[offset] & 0x80) == 0) {
            return parseOctal(buffer, offset, length);
        }
        final boolean negative = buffer[offset] == (byte) 0xff;
        if (length < 9) {
            return parseBinaryLong(buffer, offset, length, negative);
        }
        return parseBinaryBigInteger(buffer, offset, length, negative);
    }","  public void test00()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);
      assertEquals(2, int0);
      
      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);
      assertArrayEquals(new byte[] {(byte)48, (byte)32, (byte)0, (byte)0}, byteArray0);
      assertEquals(0L, long0);
  }"
"    public String getEncoding() {
        return encoding;
    }","  public void test23()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""bad CRC checksum for entry "");
      assertNotNull(mockFile0);
      
      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);
      assertTrue(mockFile0.exists());
      assertEquals(""bad CRC checksum for entry "", mockFile0.toString());
      assertFalse(mockFile0.isDirectory());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertNull(mockFile0.getParent());
      assertFalse(mockFile0.isHidden());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertTrue(mockFile0.canExecute());
      assertEquals(""bad CRC checksum for entry "", mockFile0.getName());
      assertTrue(mockFile0.canRead());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.isFile());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertEquals(0L, mockFile0.length());
      assertFalse(mockFile0.isAbsolute());
      assertTrue(zipArchiveOutputStream0.isSeekable());
      assertEquals(""UTF8"", zipArchiveOutputStream0.getEncoding());
      assertNotNull(zipArchiveOutputStream0);
      assertEquals(2048, ZipArchiveOutputStream.EFS_FLAG);
      assertEquals(0, ZipArchiveOutputStream.STORED);
      assertEquals((-1), ZipArchiveOutputStream.DEFAULT_COMPRESSION);
      assertEquals(8, ZipArchiveOutputStream.DEFLATED);
      
      zipArchiveOutputStream0.close();
      assertTrue(mockFile0.exists());
      assertEquals(""bad CRC checksum for entry "", mockFile0.toString());
      assertFalse(mockFile0.isDirectory());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertNull(mockFile0.getParent());
      assertFalse(mockFile0.isHidden());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertTrue(mockFile0.canExecute());
      assertEquals(""bad CRC checksum for entry "", mockFile0.getName());
      assertTrue(mockFile0.canRead());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.isFile());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertEquals(0L, mockFile0.length());
      assertFalse(mockFile0.isAbsolute());
      assertTrue(zipArchiveOutputStream0.isSeekable());
      assertEquals(""UTF8"", zipArchiveOutputStream0.getEncoding());
      assertEquals(2048, ZipArchiveOutputStream.EFS_FLAG);
      assertEquals(0, ZipArchiveOutputStream.STORED);
      assertEquals((-1), ZipArchiveOutputStream.DEFAULT_COMPRESSION);
      assertEquals(8, ZipArchiveOutputStream.DEFLATED);
  }"
"    public void finish() throws IOException {
        ensureOpen();

        if (this.finished) {
            return;
        }
        if (this.entry != null) {
            throw new IOException(""This archives contains unclosed entries."");
        }
        this.entry = new CpioArchiveEntry(this.entryFormat);
        this.entry.setName(CPIO_TRAILER);
        this.entry.setNumberOfLinks(1);
        writeHeader(this.entry);
        closeArchiveEntry();
    }","  public void test10()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      assertNotNull(byteArrayOutputStream0);
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);
      assertNotNull(cpioArchiveOutputStream0);
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      cpioArchiveOutputStream0.close();
      assertEquals(0, byteArrayOutputStream0.size());
      assertEquals("""", byteArrayOutputStream0.toString());
      
      try { 
        cpioArchiveOutputStream0.finish();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
      }
  }"
"    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)
            throws IOException {
        ChangeSetResults results = new ChangeSetResults();
        
        Set workingSet = new LinkedHashSet(changes);
        
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }

        ArchiveEntry entry = null;
        while ((entry = in.getNextEntry()) != null) {
            boolean copy = true;

            for (Iterator it = workingSet.iterator(); it.hasNext();) {
                Change change = (Change) it.next();

                final int type = change.type();
                final String name = entry.getName();
                if (type == Change.TYPE_DELETE && name != null) {
                    if (name.equals(change.targetFile())) {
                        copy = false;
                        it.remove();
                        results.deleted(name);
                        break;
                    }
                } else if(type == Change.TYPE_DELETE_DIR && name != null) {
                    if (name.startsWith(change.targetFile() + ""/"")) {
                        copy = false;
                        results.deleted(name);
                        break;
                    }
                }
            }

            if (copy) {
                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                    copyStream(in, out, entry);
                    results.addedFromStream(entry.getName());
                }
            }
        }
        
        // Adds files which hasn't been added from the original and do not have replace mode on
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && 
                !change.isReplaceMode() && 
                !results.hasBeenAdded(change.getEntry().getName())) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }
        return results;
    }","  public void test0()  throws Throwable  {
      ChangeSet changeSet0 = new ChangeSet();
      JarArchiveOutputStream jarArchiveOutputStream0 = new JarArchiveOutputStream((OutputStream) null);
      byte[] byteArray0 = new byte[9];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, 190);
      changeSet0.deleteDir("""");
      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, ""m"", false);
      ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
      // Undeclared exception!
      try { 
        changeSetPerformer0.perform(zipArchiveInputStream0, jarArchiveOutputStream0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream"", e);
      }
  }"
"    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {



        this.checksum = checksum;
        this.in = in;
    }","  public void test2()  throws Throwable  {
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;
      try {
        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream((Checksum) null, mockFileInputStream0);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // Parameter checksum must not be null
         //
         verifyException(""org.apache.commons.compress.utils.ChecksumCalculatingInputStream"", e);
      }
  }"
"    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {



        this.checksum = checksum;
        this.in = in;
    }","  public void test3()  throws Throwable  {
      Adler32 adler32_0 = new Adler32();
      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;
      try {
        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream(adler32_0, (InputStream) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // Parameter in must not be null
         //
         verifyException(""org.apache.commons.compress.utils.ChecksumCalculatingInputStream"", e);
      }
  }"
    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); },"  public void test27()  throws Throwable  {
      X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
      MockDate mockDate0 = new MockDate((-2), (byte)2, (byte)2);
      // Undeclared exception!
      try { 
        x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // X5455 timestamps must fit in a signed 32 bit integer: -2266876800
         //
         verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
      }
  }"
"    public ArchiveOutputStream createArchiveOutputStream(
            final String archiverName, final OutputStream out)
            throws ArchiveException {
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        if (out == null) {
            throw new IllegalArgumentException(""OutputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveOutputStream(out);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
            if (entryEncoding != null) {
                zip.setEncoding(entryEncoding);
            }
            return zip;
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new TarArchiveOutputStream(out, entryEncoding);
            } else {
                return new TarArchiveOutputStream(out);
            }
        }
        if (JAR.equalsIgnoreCase(archiverName)) {
                return new JarArchiveOutputStream(out);
        }
        if (CPIO.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new CpioArchiveOutputStream(out, entryEncoding);
            } else {
                return new CpioArchiveOutputStream(out);
            }
        }
        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }","  public void test28()  throws Throwable  {
      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory("""");
      MockPrintStream mockPrintStream0 = new MockPrintStream(""arj"");
      // Undeclared exception!
      try { 
        archiveStreamFactory0.createArchiveOutputStream(""jar"", mockPrintStream0);
        fail(""Expecting exception: IllegalCharsetNameException"");
      
      } catch(IllegalCharsetNameException e) {
         //
         // 
         //
         verifyException(""java.nio.charset.Charset"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Trim all trailing NULs and spaces.
        // The ustar and POSIX tar specs require a trailing NUL or
        // space but some implementations use the extra digit for big
        // sizes/uids/gids ...
        byte trailer = buffer[end - 1];
        if (trailer == 0 || trailer == ' '){
            end--;
        } else {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, end-1, trailer));
        }
        trailer = buffer[end - 1];
        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
            end--;
            trailer = buffer[end - 1];
        }

        for ( ;start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test10()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byteArray0[2] = (byte)32;
      byteArray0[3] = (byte)32;
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, 2, 2);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid byte 32 at offset 2 in '  ' len=2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public SevenZFile(final File filename, final byte[] password) throws IOException {
        boolean succeeded = false;
        this.file = new RandomAccessFile(filename, ""r"");
        this.fileName = filename.getAbsolutePath();
        try {
            archive = readHeaders(password);
            if (password != null) {
                this.password = new byte[password.length];
                System.arraycopy(password, 0, this.password, 0, password.length);
            } else {
                this.password = null;
            }
            succeeded = true;
        } finally {
            if (!succeeded) {
                this.file.close();
            }
        }
    }","  public void test0()  throws Throwable  {
      MockFile mockFile0 = new MockFile(""}$LSF"");
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""}$LSF"");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ""}$LSF"");
      SevenZFile sevenZFile0 = null;
      try {
        sevenZFile0 = new SevenZFile(mockFile0);
        fail(""Expecting exception: EOFException"");
      
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.io.RandomAccessFile"", e);
      }
  }"
"    public static boolean matches(final byte[] signature, final int length) {
        if (length < sevenZSignature.length) {
            return false;
        }

        for (int i = 0; i < sevenZSignature.length; i++) {
            if (signature[i] != sevenZSignature[i]) {
                return false;
            }
        }
        return true;
    }","  public void test3()  throws Throwable  {
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)55;
      boolean boolean0 = SevenZFile.matches(byteArray0, (byte)55);
      assertFalse(boolean0);
  }"
"    public ArchiveInputStream createArchiveInputStream(
            final String archiverName, final InputStream in)
            throws ArchiveException {
        
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        
        if (in == null) {
            throw new IllegalArgumentException(""InputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveInputStream(in);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            return new ZipArchiveInputStream(in);
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            return new TarArchiveInputStream(in);
        }
        if (JAR.equalsIgnoreCase(archiverName)) {
            return new JarArchiveInputStream(in);
        }
        if (CPIO.equalsIgnoreCase(archiverName)) {
            return new CpioArchiveInputStream(in);
        }
        if (DUMP.equalsIgnoreCase(archiverName)) {
            return new DumpArchiveInputStream(in);
        }
        
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }","  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[179];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory();
      try { 
        archiveStreamFactory0.createArchiveInputStream((InputStream) byteArrayInputStream0);
        fail(""Expecting exception: Exception"");
      
      } catch(Exception e) {
         //
         // No Archiver found for the stream signature
         //
         verifyException(""org.apache.commons.compress.archivers.ArchiveStreamFactory"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        int     start = offset;

        for (int i = start; i < end; i++){
            final byte currentByte = buffer[i];
            if (currentByte == 0) {
                break;
            }

        // Skip leading spaces
            if (currentByte == (byte) ' ' || currentByte == '0') {
                if (stillPadding) {
                   continue;
            }
                if (currentByte == (byte) ' ') {
                break;
                }
            }

        // Must have trailing NUL or space
        // May have additional NUL or space

            stillPadding = false;
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test02()  throws Throwable  {
      byte[] byteArray0 = new byte[25];
      byteArray0[4] = (byte)54;
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, (byte)3, 2);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid byte 54 at offset 1 in '{NUL}6' len=2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        int     start = offset;

        for (int i = start; i < end; i++){
            final byte currentByte = buffer[i];
            if (currentByte == 0) {
                break;
            }

        // Skip leading spaces
            if (currentByte == (byte) ' ' || currentByte == '0') {
                if (stillPadding) {
                   continue;
            }
                if (currentByte == (byte) ' ') {
                break;
                }
            }

        // Must have trailing NUL or space
        // May have additional NUL or space

            stillPadding = false;
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      // Undeclared exception!
      try { 
        TarUtils.parseOctal(byteArray0, (byte)3, (byte)0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Length 0 must be at least 2
         //
         verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
      }
  }"
"    public ZipArchiveEntry getNextZipEntry() throws IOException {
        boolean firstEntry = true;
        if (closed || hitCentralDirectory) {
            return null;
        }
        if (current != null) {
            closeEntry();
            firstEntry = false;
        }

        try {
            if (firstEntry) {
                // split archives have a special signature before the
                // first local file header - look for it and fail with
                // the appropriate error message if this is a split
                // archive.
                readFirstLocalFileHeader(LFH_BUF);
            } else {
                readFully(LFH_BUF);
            }
        } catch (final EOFException e) {
            return null;
        }

        final ZipLong sig = new ZipLong(LFH_BUF);
        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
            hitCentralDirectory = true;
            skipRemainderOfArchive();
        }
        if (!sig.equals(ZipLong.LFH_SIG)) {
            return null;
        }

        int off = WORD;
        current = new CurrentEntry();

        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;
        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);

        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
        current.hasDataDescriptor = gpFlag.usesDataDescriptor();
        current.entry.setGeneralPurposeBit(gpFlag);

        off += SHORT;

        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
        off += SHORT;

        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
        current.entry.setTime(time);
        off += WORD;

        ZipLong size = null, cSize = null;
        if (!current.hasDataDescriptor) {
            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
            off += WORD;

            cSize = new ZipLong(LFH_BUF, off);
            off += WORD;

            size = new ZipLong(LFH_BUF, off);
            off += WORD;
        } else {
            off += 3 * WORD;
        }

        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);

        off += SHORT;

        final int extraLen = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;

        final byte[] fileName = new byte[fileNameLen];
        readFully(fileName);
        current.entry.setName(entryEncoding.decode(fileName), fileName);

        final byte[] extraData = new byte[extraLen];
        readFully(extraData);
        current.entry.setExtra(extraData);

        if (!hasUTF8Flag && useUnicodeExtraFields) {
            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
        }

        processZip64Extra(size, cSize);

        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
                current.in = new ExplodingInputStream(
                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),
                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),
                        new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            }
        }
        
        entriesRead++;
        return current.entry;
    }","  public void test03()  throws Throwable  {
      byte[] byteArray0 = new byte[40];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
      try { 
        zipArchiveInputStream0.getNextZipEntry();
        fail(""Expecting exception: ZipException"");
      
      } catch(ZipException e) {
         //
         // Unexpected record signature: 0X0
         //
         verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
      }
  }"
"    public ArArchiveEntry getNextArEntry() throws IOException {
                    // hit EOF before previous entry was complete
                    // TODO: throw an exception instead?

        if (offset == 0) {
            final byte[] expected = ArArchiveEntry.HEADER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid header "" + new String(realized));
                }
            }
        }

                // hit eof

        if (input.available() == 0) {
            return null;
        }

        if (offset % 2 != 0) {
            read();
        }
        final byte[] name = new byte[16];
        final byte[] lastmodified = new byte[12];
        final byte[] userid = new byte[6];
        final byte[] groupid = new byte[6];
        final byte[] filemode = new byte[8];
        final byte[] length = new byte[10];

        read(name);
        read(lastmodified);
        read(userid);
        read(groupid);
        read(filemode);
        read(length);

        {
            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read entry header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid entry header. not read the content?"");
                }
            }
        }

        return new ArArchiveEntry(new String(name).trim(),
                                          Long.parseLong(new String(length)
                                                         .trim()));
    }","  public void test04()  throws Throwable  {
      byte[] byteArray0 = new byte[2];
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);
      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);
      arArchiveInputStream0.read();
      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();
      assertNull(arArchiveEntry0);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test19()  throws Throwable  {
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);
      assertNotSame(zip64ExtendedInformationExtraField0, zip64ExtendedInformationExtraField1);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test23()  throws Throwable  {
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 22);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, false, true, false);
  }"
"    public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                + (hasCompressedSize ? DWORD : 0)
                + (hasRelativeHeaderOffset ? DWORD : 0)
                + (hasDiskStart ? WORD : 0);
            if (rawCentralDirectoryData.length != expectedLength) {
                throw new ZipException(""central directory zip64 extended""
                                       + "" information extra field's length""
                                       + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","  public void test24()  throws Throwable  {
      ZipLong zipLong0 = ZipLong.AED_SIG;
      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));
      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 16);
      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, false, true);
  }"
"    public static long parseOctalOrBinary(final byte[] buffer, final int offset,
                                          final int length) {

        if ((buffer[offset] & 0x80) == 0) {
            return parseOctal(buffer, offset, length);
        }
        final boolean negative = buffer[offset] == (byte) 0xff;
        if (length < 9) {
            return parseBinaryLong(buffer, offset, length, negative);
        }
        return parseBinaryBigInteger(buffer, offset, length, negative);
    }","  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[36];
      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);
      assertEquals(12, int0);
      
      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);
      assertEquals(6L, long0);
  }"
"    public void writeEmbeddedObject(Object object) throws IOException {
        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases
        throw new JsonGenerationException(""No native support for writing embedded objects"",
                this);
    }","  public void test45()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);
      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
  }"
    public boolean isResourceManaged() { return _managedResource; },"  public void test22()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      Object object0 = new Object();
      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
      iOContext0.allocWriteEncodingBuffer();
      byte[] byteArray0 = iOContext0.allocReadIOBuffer();
      iOContext0.releaseWriteEncodingBuffer(byteArray0);
      assertTrue(iOContext0.isResourceManaged());
  }"
"    public Boolean nextBooleanValue()
        throws IOException, JsonParseException
    {
        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'
            _nameCopied = false;
            JsonToken t = _nextToken;
            _nextToken = null;
            _currToken = t;
            if (t == JsonToken.VALUE_TRUE) {
                return Boolean.TRUE;
            }
            if (t == JsonToken.VALUE_FALSE) {
                return Boolean.FALSE;
            }
            if (t == JsonToken.START_ARRAY) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            } else if (t == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            return null;
        }
        switch (nextToken()) {
        case VALUE_TRUE:
            return Boolean.TRUE;
        case VALUE_FALSE:
            return Boolean.FALSE;
        default:
        	return null;
        }
    }","  public void test26()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(bufferRecycler0);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, ""1IoL_.}7~~\""HL_r*"", false);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(iOContext0);
      assertNull(iOContext0.getEncoding());
      assertFalse(iOContext0.isResourceManaged());
      
      StringReader stringReader0 = new StringReader(""0JMmtsG8ryBAGj-U!"");
      assertNotNull(stringReader0);
      
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(charsToNameCanonicalizer0);
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      
      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(readerBasedJsonParser0);
      assertNull(iOContext0.getEncoding());
      assertFalse(iOContext0.isResourceManaged());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertNull(readerBasedJsonParser0.getCurrentName());
      assertNull(readerBasedJsonParser0.getLastClearedToken());
      assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
      assertFalse(readerBasedJsonParser0.canReadTypeId());
      assertFalse(readerBasedJsonParser0.canReadObjectId());
      assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
      assertFalse(readerBasedJsonParser0.requiresCustomCodec());
      assertFalse(readerBasedJsonParser0.isClosed());
      assertFalse(readerBasedJsonParser0.hasTextCharacters());
      assertFalse(readerBasedJsonParser0.hasCurrentToken());
      assertEquals(2000, readerBasedJsonParser0.getFeatureMask());
      assertNull(readerBasedJsonParser0.getCurrentToken());
      assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
      
      try { 
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Unexpected character ('J' (code 74)): Expected space separating root-level values
         //  at [Source: java.lang.String@0000000014; line: 1, column: 3]
         //
         verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
      }
  }"
"    public JsonToken nextToken()
        throws IOException, JsonParseException
    {
        _numTypesValid = NR_UNKNOWN;

        /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
        if (_currToken == JsonToken.FIELD_NAME) {
            return _nextAfterName();
        }
        if (_tokenIncomplete) {
            _skipString(); // only strings can be partial
        }
        int i = _skipWSOrEnd();
        if (i < 0) { // end-of-input
            /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
            close();
            return (_currToken = null);
        }

        /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
        _tokenInputRow = _currInputRow;
        _tokenInputCol = _inputPtr - _currInputRowStart - 1;

        // finally: clear any data retained so far
        _binaryValue = null;

        // Closing scope?
        if (i == INT_RBRACKET) {
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_ARRAY);
        }","  public void test27()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(bufferRecycler0);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertNotNull(iOContext0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      
      StringReader stringReader0 = new StringReader(""1IoL_.}7~~\""HL_r*"");
      assertNotNull(stringReader0);
      
      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(charsToNameCanonicalizer0);
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      
      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1722), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
      assertEquals(2000, BufferRecycler.DEFAULT_WRITE_CONCAT_BUFFER_LEN);
      assertEquals(33, CharsToNameCanonicalizer.HASH_MULT);
      assertNotNull(readerBasedJsonParser0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertEquals(0, charsToNameCanonicalizer0.collisionCount());
      assertEquals(839877741, charsToNameCanonicalizer0.hashSeed());
      assertEquals(0, charsToNameCanonicalizer0.size());
      assertFalse(charsToNameCanonicalizer0.maybeDirty());
      assertEquals(64, charsToNameCanonicalizer0.bucketCount());
      assertEquals(0, charsToNameCanonicalizer0.maxCollisionLength());
      assertNull(readerBasedJsonParser0.getCurrentName());
      assertFalse(readerBasedJsonParser0.isClosed());
      assertNull(readerBasedJsonParser0.getCurrentToken());
      assertNull(readerBasedJsonParser0.getLastClearedToken());
      assertFalse(readerBasedJsonParser0.canReadTypeId());
      assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
      assertEquals((-1722), readerBasedJsonParser0.getFeatureMask());
      assertFalse(readerBasedJsonParser0.requiresCustomCodec());
      assertFalse(readerBasedJsonParser0.canReadObjectId());
      assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
      assertFalse(readerBasedJsonParser0.hasCurrentToken());
      assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
      assertFalse(readerBasedJsonParser0.hasTextCharacters());
      
      try { 
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
      
      } catch(IOException e) {
         //
         // Unexpected character ('I' (code 73)): Expected space separating root-level values
         //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 3]
         //
         verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test29()  throws Throwable  {
      TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
      textBuffer0.contentsAsArray();
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test30()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.getCurrentSegment();
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test31()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      BufferRecycler.CharBufferType bufferRecycler_CharBufferType0 = BufferRecycler.CharBufferType.TOKEN_BUFFER;
      char[] charArray0 = bufferRecycler0.allocCharBuffer(bufferRecycler_CharBufferType0);
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithShared(charArray0, 1, 1);
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test32()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.getCurrentSegment();
      textBuffer0.setCurrentLength(2000);
      textBuffer0.append('7');
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }","  public void test44()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
      textBuffer0.resetWithShared((char[]) null, 2000, 2000);
      // Undeclared exception!
      try { 
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.util.Arrays"", e);
      }
  }"
"    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException
    {
            return new BigDecimal(numStr);
    }","  public void test00()  throws Throwable  {
      char[] charArray0 = new char[3];
      try { 
        NumberInput.parseBigDecimal(charArray0);
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // Value \""\u0000\u0000\u0000\"" can not be represented as BigDecimal
         //
         verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
      }
  }"
"    public void writeNumber(short s) throws IOException
    {
        _verifyValueWrite(WRITE_NUMBER);
        // up to 5 digits and possible minus sign
        if ((_outputTail + 6) >= _outputEnd) {
            _flushBuffer();
        }
        if (_cfgNumbersAsStrings) {
            _writeQuotedShort(s);
            return;
        }
        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
    }","  public void test69()  throws Throwable  {
      BufferRecycler bufferRecycler0 = new BufferRecycler();
      assertNotNull(bufferRecycler0);
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      
      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
      assertNotNull(iOContext0);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      
      MockFile mockFile0 = new MockFile(""i]mir@"");
      assertNotNull(mockFile0);
      
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      assertNotNull(mockFileOutputStream0);
      
      byte[] byteArray0 = new byte[1];
      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 154, true);
      assertNotNull(uTF8JsonGenerator0);
      assertArrayEquals(new byte[] {(byte)0}, byteArray0);
      assertEquals(1, byteArray0.length);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertFalse(mockFile0.isDirectory());
      assertNull(mockFile0.getParent());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertFalse(mockFile0.isAbsolute());
      assertEquals(""i]mir@"", mockFile0.getName());
      assertEquals(0L, mockFile0.length());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertTrue(mockFile0.canExecute());
      assertTrue(mockFile0.isFile());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.canRead());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertFalse(mockFile0.isHidden());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertTrue(mockFile0.exists());
      assertEquals(""i]mir@"", mockFile0.toString());
      assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
      assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
      assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
      assertFalse(uTF8JsonGenerator0.canWriteObjectId());
      assertEquals(154, uTF8JsonGenerator0.getOutputBuffered());
      assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
      assertFalse(uTF8JsonGenerator0.canWriteTypeId());
      assertTrue(uTF8JsonGenerator0.canOmitFields());
      assertFalse(uTF8JsonGenerator0.isClosed());
      assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      assertEquals(56319, GeneratorBase.SURR1_LAST);
      assertEquals(56320, GeneratorBase.SURR2_FIRST);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
      assertEquals(55296, GeneratorBase.SURR1_FIRST);
      
      uTF8JsonGenerator0.writeString((char[]) null, 2, 0);
      assertArrayEquals(new byte[] {(byte)34}, byteArray0);
      assertEquals(1, byteArray0.length);
      assertTrue(iOContext0.isResourceManaged());
      assertNull(iOContext0.getEncoding());
      assertFalse(mockFile0.isDirectory());
      assertEquals(2L, mockFile0.length());
      assertNull(mockFile0.getParent());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertFalse(mockFile0.isAbsolute());
      assertEquals(""i]mir@"", mockFile0.getName());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertTrue(mockFile0.canExecute());
      assertTrue(mockFile0.isFile());
      assertTrue(mockFile0.canWrite());
      assertTrue(mockFile0.canRead());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertFalse(mockFile0.isHidden());
      assertEquals(1392409281320L, mockFile0.lastModified());
      assertTrue(mockFile0.exists());
      assertEquals(""i]mir@"", mockFile0.toString());
      assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
      assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
      assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
      assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
      assertFalse(uTF8JsonGenerator0.canWriteObjectId());
      assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
      assertFalse(uTF8JsonGenerator0.canWriteTypeId());
      assertTrue(uTF8JsonGenerator0.canOmitFields());
      assertFalse(uTF8JsonGenerator0.isClosed());
      assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
      assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
      assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
      assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
      assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
      assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
      assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
      assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
      assertEquals(56319, GeneratorBase.SURR1_LAST);
      assertEquals(56320, GeneratorBase.SURR2_FIRST);
      assertEquals(57343, GeneratorBase.SURR2_LAST);
      assertEquals(55296, GeneratorBase.SURR1_FIRST);
      
      // Undeclared exception!
      try { 
        uTF8JsonGenerator0.writeNumber((-1.0F));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
      }
  }"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test12()  throws Throwable  {
      StdDateFormat stdDateFormat0 = new StdDateFormat();
      stdDateFormat0.instance.setLenient(true);
      assertTrue(stdDateFormat0.isLenient());
  }"
"    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }","  public void test13()  throws Throwable  {
      StdDateFormat stdDateFormat0 = new StdDateFormat();
      stdDateFormat0.setLenient(false);
      assertFalse(stdDateFormat0.isLenient());
  }"
"    public long getLongValue() throws IOException {
        final NumericNode node = (NumericNode) currentNumericNode();
        return node.longValue();
    }","  public void test34()  throws Throwable  {
      LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));
      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);
      // Undeclared exception!
      try { 
        treeTraversingParser0.getLongValue();
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.fasterxml.jackson.databind.node.TreeTraversingParser"", e);
      }
  }"
"    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException
    {
        if (_value == null) {
            ctxt.defaultSerializeNull(gen);
        } else if (_value instanceof JsonSerializable) {
            ((JsonSerializable) _value).serialize(gen, ctxt);
        } else {
            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;
            //    this to preserve contextual information
            gen.writeObject(_value);
        }
    }","  public void test18()  throws Throwable  {
      POJONode pOJONode0 = new POJONode(""b4axvGC0V"");
      JsonFactory jsonFactory0 = new JsonFactory();
      StringWriter stringWriter0 = new StringWriter();
      JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((Writer) stringWriter0);
      // Undeclared exception!
      try { 
        pOJONode0.serialize(jsonGenerator0, (SerializerProvider) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.fasterxml.jackson.databind.node.POJONode"", e);
      }
  }"
"    public int capacity() {
        return buffer.length;
    }","  public void test015()  throws Throwable  {
      StrBuilder strBuilder0 = new StrBuilder((String) null);
      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');
      assertEquals(45, strBuilder0.capacity());
  }"
"    public int length() {
        return size;
    }","  public void test132()  throws Throwable  {
      StrBuilder strBuilder0 = new StrBuilder(574);
      assertNotNull(strBuilder0);
      assertEquals(0, strBuilder0.length());
      assertTrue(strBuilder0.isEmpty());
      assertNull(strBuilder0.getNewLineText());
      assertEquals(574, strBuilder0.capacity());
      assertNull(strBuilder0.getNullText());
      assertEquals(0, strBuilder0.size());
      
      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\'');
      assertNotNull(strBuilder1);
      assertSame(strBuilder0, strBuilder1);
      assertSame(strBuilder1, strBuilder0);
      assertEquals(574, strBuilder0.length());
      assertEquals(574, strBuilder0.size());
      assertNull(strBuilder0.getNewLineText());
      assertEquals(574, strBuilder0.capacity());
      assertFalse(strBuilder0.isEmpty());
      assertNull(strBuilder0.getNullText());
      assertEquals(574, strBuilder1.size());
      assertFalse(strBuilder1.isEmpty());
      assertNull(strBuilder1.getNewLineText());
      assertEquals(574, strBuilder1.capacity());
      assertNull(strBuilder1.getNullText());
      assertEquals(574, strBuilder1.length());
  }"
"    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
            type = Object.class;
        }
        @SuppressWarnings(""unchecked"") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }","  public void test349()  throws Throwable  {
      // Undeclared exception!
      try { 
        ArrayUtils.add((Object[]) null, (Object) null);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Arguments cannot both be null
         //
         verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
      }
  }"
"    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
            type = Object.class;
        }
        @SuppressWarnings(""unchecked"") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }","  public void test352()  throws Throwable  {
      // Undeclared exception!
      try { 
        ArrayUtils.add((Integer[]) null, (-7), (Integer) null);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Array and element cannot both be null
         //
         verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
            int hexDigits = str.length() - 2; // drop 0x
            if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test035()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""--X+.\""LnzwmpM1g+fl"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // --X+.\""LnzwmpM1g+fl is not a valid number.
         //
         verifyException(""org.apache.commons.lang3.math.NumberUtils"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
            int hexDigits = str.length() - 2; // drop 0x
            if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test047()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""--0XVG\""AMz:>EyhF"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // --0XVG\""AMz:>EyhF is not a valid number.
         //
         verifyException(""org.apache.commons.lang3.math.NumberUtils"", e);
      }
  }"
"    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        // initial parameter checks
        if (str == null) {
            return null;
        }
        if (str.length() == 0) {
            return StringUtils.EMPTY;
        }

        // if the lower value is greater than the length of the string,
        // set to the length of the string
        // if the upper value is -1 (i.e. no limit) or is greater
        // than the length of the string, set to the length of the string
        if (upper == -1 || upper > str.length()) {
            upper = str.length();
        }
        // if upper is less than lower, raise it to lower
        if (upper < lower) {
            upper = lower;
        }

        StringBuffer result = new StringBuffer();
        int index = StringUtils.indexOf(str, "" "", lower);
        if (index == -1) {
            result.append(str.substring(0, upper));
            // only if abbreviation has occured do we append the appendToEnd value
            if (upper != str.length()) {
                result.append(StringUtils.defaultString(appendToEnd));
            }
        } else if (index > upper) {
            result.append(str.substring(0, upper));
            result.append(StringUtils.defaultString(appendToEnd));
        } else {
            result.append(str.substring(0, index));
            result.append(StringUtils.defaultString(appendToEnd));
        }
        return result.toString();
    }","  public void test30()  throws Throwable  {
      String string0 = WordUtils.abbreviate(""wTDdt<TJing. Mac"", 421, 13, "" "");
      assertEquals(""wTDdt<TJing. Mac"", string0);
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test00()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.US;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\"" ; gave up at index 83
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test01()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.ENGLISH;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""HZJV^H"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""HZJV^H\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test02()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone(""WyGf<\""J"");
      Locale locale0 = Locale.CHINESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""WyGf<\""J"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""WyGf<\""J\"" ; gave up at index 3
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test17()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.FRANCE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""`@Z$=yy`/|$~1LALU&P"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""`@Z$=yy`/|$~1LALU&P\"" ; gave up at index 13
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test21()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""S(X"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""S(X\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test23()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.CHINESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""W*f<\""T(HJH"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""W*f<\""T(HJH\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test25()  throws Throwable  {
      Locale locale0 = new Locale(""Zt`q("", ""Zt`q("", ""Zt`q("");
      TimeZone timeZone0 = TimeZone.getTimeZone(""Zt`q("");
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""-7|@]F5Tc%m($PLP~tw"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""-7|@]F5Tc%m($PLP~tw\"" ; gave up at index 7
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test27()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.GERMAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""/,q3rndcZ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""/,q3rndcZ\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test29()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone("";J&%Dl.p[7Zh_nAhzE"");
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""FH2(bMqDjaKCbX"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""FH2(bMqDjaKCbX\"" ; gave up at index 4
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test30()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""3fr&HfA"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""3fr&HfA\"" ; gave up at index 1
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test31()  throws Throwable  {
      Locale locale0 = new Locale(""6I"", ""6I"", ""D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"");
      TimeZone timeZone0 = TimeZone.getTimeZone(""SNXk?8a4BQ_3A|Q+i"");
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""6I"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""6I\"" ; gave up at index 1
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test33()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.GERMAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""88vf,z'r"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""88vf,z'r\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test34()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getTimeZone(""9*f<\""H*H"");
      Locale locale0 = Locale.US;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""9*f<\""H*H"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""9*f<\""H*H\"" ; gave up at index 2
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test36()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.JAPANESE;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""`@Z=yy`/|$~1LALU&P"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""`@Z=yy`/|$~1LALU&P\"" ; gave up at index 12
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test37()  throws Throwable  {
      Locale locale0 = Locale.ENGLISH;
      TimeZone timeZone0 = TimeZone.getDefault();
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""]k>QHlD*"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""]k>QHlD*\"" ; gave up at index 3
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {
        this.pattern = pattern;
        this.timeZone = timeZone;
        this.locale = locale;
        init();
    }","  public void test39()  throws Throwable  {
      TimeZone timeZone0 = TimeZone.getDefault();
      Locale locale0 = Locale.KOREAN;
      FastDateParser fastDateParser0 = null;
      try {
        fastDateParser0 = new FastDateParser(""@SKFxk)?Aeh4iJ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Failed to parse \""@SKFxk)?Aeh4iJ\"" ; gave up at index 4
         //
         verifyException(""org.apache.commons.lang3.time.FastDateParser"", e);
      }
  }"
"    public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return ArrayUtils.EMPTY_CLASS_ARRAY;
        }
        Class<?>[] classes = new Class[array.length];
        for (int i = 0; i < array.length; i++) {
            classes[i] = array[i].getClass();
        }
        return classes;
    }","  public void test73()  throws Throwable  {
      Object[] objectArray0 = new Object[3];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
      assertEquals(3, classArray0.length);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && isDigits(numeric.substring(1))
                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test030()  throws Throwable  {
      Number number0 = NumberUtils.createNumber(""6l"");
      assertEquals(6L, number0);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test017()  throws Throwable  {
      try { 
        NumberUtils.createNumber("".."");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""java.math.BigDecimal"", e);
      }
  }"
"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }","  public void test18()  throws Throwable  {
      boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);
      assertFalse(boolean0);
  }"
"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }","  public void test19()  throws Throwable  {
      Locale locale0 = Locale.ENGLISH;
      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);
      assertTrue(boolean0);
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test023()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""0Xz46Pe"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \""z46Pe\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
"    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","  public void test024()  throws Throwable  {
      try { 
        NumberUtils.createNumber(""-0X"");
        fail(""Expecting exception: NumberFormatException"");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \""-\""
         //
         verifyException(""java.lang.NumberFormatException"", e);
      }
  }"
"    public static String getPackageName(Object object, String valueIfNull) {
        if (object == null) {
            return valueIfNull;
        }
        return getPackageName(object.getClass());
    }","  public void test21()  throws Throwable  {
      // Undeclared exception!
      try { 
        ClassUtils.getPackageName(""["");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test2()  throws Throwable  {
      char[] charArray0 = new char[7];
      charArray0[3] = '&';
      charArray0[4] = '#';
      charArray0[5] = 'X';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0000\u0000\u0000&#X\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test3()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[3] = '&';
      charArray0[4] = '#';
      charArray0[5] = 'X';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0000\u0000\u0000&#X"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test4()  throws Throwable  {
      char[] charArray0 = new char[3];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'b';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#b"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test5()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = '4';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0004\u0000\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test6()  throws Throwable  {
      char[] charArray0 = new char[5];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'l';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#l\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test7()  throws Throwable  {
      char[] charArray0 = new char[6];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = 'B';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""&#B\u0000\u0000\u0000"", string0);
  }"
"    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(input.charAt(end) != ';') 
            {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","  public void test8()  throws Throwable  {
      char[] charArray0 = new char[3];
      charArray0[0] = '&';
      charArray0[1] = '#';
      charArray0[2] = '4';
      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
      assertEquals(""\u0004"", string0);
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test03()  throws Throwable  {
      FastDateFormat.getInstance(""zwSDshmD{kc5G"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test23()  throws Throwable  {
      FastDateFormat.getInstance(""<{H#AMf"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test24()  throws Throwable  {
      FastDateFormat.getInstance(""%5FBU6V+=$JW5@7p"");
  }"
"    public static FastDateFormat getInstance() {
        return cache.getDateTimeInstance(SHORT, SHORT, null, null);
    }","  public void test25()  throws Throwable  {
      FastDateFormat.getInstance(""2C oyYB9sU>d"");
  }"
