label,test,fm
0,"public void testSize() { LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>(); PropertyOption propertyOption0 = PropertyOption.INSTANCE; WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0); List list0 = writeableCommandLineImpl0.getOptions(); FileValidator fileValidator0 = FileValidator.getExistingDirectoryInstance(); ArgumentImpl argumentImpl0 = new ArgumentImpl(""[af`YR"", ""DJ;%"", 124, 124, 'I', 'I', fileValidator0, ""Option.missing.required"", list0, 124); writeableCommandLineImpl0.addSwitch(argumentImpl0, false); writeableCommandLineImpl0.addValue(argumentImpl0, ""Option.missing.required""); writeableCommandLineImpl0.getValues((Option) argumentImpl0, (List) list0); }",public int size() { return this.size; }
0,"public void testFlatten() { PosixParser posixParser0 = new PosixParser(); Options options0 = new Options(); String[] stringArray0 = new String[2]; stringArray0[0] = ""-ub\""vdz(*j""; posixParser0.flatten(options0, stringArray0, true); }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) { init(); this.options = options; // an iterator for the command line tokens Iterator iter = Arrays.asList(arguments).iterator(); // process each command line token while (iter.hasNext()) { // get the next command line token String token = (String) iter.next(); // handle SPECIAL TOKEN if (token.startsWith(""--"")) { if (token.indexOf('=') != -1) { tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); } else { tokens.add(token); } } // single hyphen else if (""-"".equals(token)) { processSingleHyphen(token); } else if (token.startsWith(""-"")) { int tokenLength = token.length(); if (tokenLength == 2) { processOptionToken(token, stopAtNonOption); } else if (options.hasOption(token)) { tokens.add(token); } // requires bursting else { burstToken(token, stopAtNonOption); } } else { if (stopAtNonOption) { process(token); } else { tokens.add(token); } } gobble(iter); } return (String[]) tokens.toArray(new String[tokens.size()]); }"
0,"public void testFlatten() { PosixParser posixParser0 = new PosixParser(); Options options0 = new Options(); String[] stringArray0 = new String[2]; stringArray0[0] = ""- ""; posixParser0.flatten(options0, stringArray0, true); }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) { init(); this.options = options; // an iterator for the command line tokens Iterator iter = Arrays.asList(arguments).iterator(); // process each command line token while (iter.hasNext()) { // get the next command line token String token = (String) iter.next(); // handle SPECIAL TOKEN if (token.startsWith(""--"")) { if (token.indexOf('=') != -1) { tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); } else { tokens.add(token); } } // single hyphen else if (""-"".equals(token)) { processSingleHyphen(token); } else if (token.startsWith(""-"")) { if (token.length() == 2) { processOptionToken(token, stopAtNonOption); } else if (options.hasOption(token)) { tokens.add(token); } // requires bursting else { burstToken(token, stopAtNonOption); } } else if (stopAtNonOption) { process(token); } else { tokens.add(token); } gobble(iter); } return (String[]) tokens.toArray(new String[tokens.size()]); }"
0,"public void testFlatten() { PosixParser posixParser0 = new PosixParser(); Options options0 = new Options(); options0.addOption(""P"", true, ""T""); String[] stringArray0 = new String[4]; stringArray0[0] = ""-PE---""; stringArray0[1] = ""-8""; posixParser0.flatten(options0, stringArray0, true); }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) { init(); this.options = options; // an iterator for the command line tokens Iterator iter = Arrays.asList(arguments).iterator(); // process each command line token while (iter.hasNext()) { // get the next command line token String token = (String) iter.next(); // handle long option --foo or --foo=bar if (token.startsWith(""--"")) { int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt)) { processNonOptionToken(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); } } } // single hyphen else if (""-"".equals(token)) { tokens.add(token); } else if (token.startsWith(""-"")) { if (token.length() == 2 || options.hasOption(token)) { processOptionToken(token, stopAtNonOption); } // requires bursting else { burstToken(token, stopAtNonOption); } } else if (stopAtNonOption) { processNonOptionToken(token); } else { tokens.add(token); } gobble(iter); } return (String[]) tokens.toArray(new String[tokens.size()]); }"
0,"public void testLength() { HelpFormatter helpFormatter0 = new HelpFormatter(); StringBuffer stringBuffer0 = new StringBuffer(); Options options0 = new Options(); Options options1 = options0.addOption(""t"", false, ""--""); helpFormatter0.renderOptions(stringBuffer0, 68, options1, 144, 1); }",public int length() { return this.length; }
0,"public void testStripLeadingAndTrailingQuotes() { Util.stripLeadingAndTrailingQuotes(""\""qDxD_5>q,)`dEgM""); }","static String stripLeadingAndTrailingQuotes(String str) { if (str.startsWith(""\"""")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith(""\"""")) { str = str.substring(0, length - 1); } return str; }"
0,"public void testStripLeadingAndTrailingQuotes() { Util.stripLeadingAndTrailingQuotes(""\""\"" |B_#\""""); }","static String stripLeadingAndTrailingQuotes(String str) { if (str.startsWith(""\"""")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith(""\"""")) { str = str.substring(0, length - 1); } return str; }"
0,"public void testGetArgs() { Option option0 = new Option(""4"", ""4""); option0.hasArgName(); }",public int getArgs() { return numberOfArgs; }
0,"public void testGetType() { Option option0 = new Option("""", """", true, ""'""); option0.getType(); }",public Object getType() { return type; }
0,"public void testGetArgs() { Option option0 = new Option("""", """"); option0.toString(); }",public int getArgs() { return numberOfArgs; }
0,"public void testToString() { Option option0 = new Option("""", ""X84U-w?C*"", true, """"); option0.toString(); }","public String toString() { StringBuffer buf = new StringBuffer().append(""[ option: ""); buf.append(opt); if (longOpt != null) { buf.append("" "").append(longOpt); } buf.append("" ""); if (hasArgs()) { buf.append(""[ARG...]""); } else if (hasArg()) { buf.append("" [ARG]""); } buf.append("" :: "").append(description); if (type != null) { buf.append("" :: "").append(type); } buf.append("" ]""); return buf.toString(); }"
0,"public void testHasArg() { new Option("""", """"); }",public boolean hasArg() { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES; }
0,public void testIsArrayByteBase64() { byte[] byteArray0 = Base64.CHUNK_SEPARATOR; Base64.isArrayByteBase64(byteArray0); },public static boolean isArrayByteBase64(byte[] arrayOctet) { for (int i = 0; i < arrayOctet.length; i++) { if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) { return false; } } return true; }
0,public void testDiscardWhitespace() { byte[] byteArray0 = Base64.CHUNK_SEPARATOR; Base64.discardWhitespace(byteArray0); },"static byte[] discardWhitespace(byte[] data) { byte groomedData[] = new byte[data.length]; int bytesCopied = 0; for (int i = 0; i < data.length; i++) { switch (data[i]) { case ' ' : case '\n' : case '\r' : case '\t' : break; default : groomedData[bytesCopied++] = data[i]; } } byte packedData[] = new byte[bytesCopied]; System.arraycopy(groomedData, 0, packedData, 0, bytesCopied); return packedData; }"
0,"public void testEncodeQuotedPrintable() { byte[] byteArray0 = new byte[9]; byteArray0[1] = (byte) (-18); byteArray0[2] = (byte)1; byteArray0[3] = (byte)9; byteArray0[4] = (byte) (-18); byteArray0[5] = (byte)96; byteArray0[6] = (byte)9; byteArray0[8] = (byte)16; ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0); BitSet bitSet0 = BitSet.valueOf(byteBuffer0); byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0); byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1); byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2); QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray3); }","private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); }"
0,"public void testEncodeQuotedPrintable() { byte[] byteArray0 = new byte[9]; byteArray0[6] = (byte)9; ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0); BitSet bitSet0 = BitSet.valueOf(byteBuffer0); byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0); byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1); QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2); }","private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); }"
0,public void testEncode() { QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec(); byte[] byteArray0 = new byte[4]; byteArray0[3] = (byte)9; quotedPrintableCodec0.encode(byteArray0); },"public byte[] encode(byte[] bytes) { return encodeQuotedPrintable(PRINTABLE_CHARS, bytes); }"
0,"public void testEncodeQuotedPrintable() { byte[] byteArray0 = new byte[9]; byteArray0[0] = (byte)53; byteArray0[1] = (byte) (-18); byteArray0[2] = (byte)1; byteArray0[5] = (byte)96; byteArray0[6] = (byte)9; ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0); BitSet bitSet0 = BitSet.valueOf(byteBuffer0); byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0); byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1); QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2); }","private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); }"
0,"public void testAvailable() { byte[] byteArray0 = new byte[1]; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597); Base64 base64_0 = new Base64((-2146420536)); BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, true); baseNCodecInputStream0.skip(597); }",public int available() { return this.available; }
0,"public void testAvailable() { byte[] byteArray0 = new byte[3]; Base32 base32_0 = new Base32(); ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0); BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false); baseNCodecInputStream0.available(); }",public int available() { return this.available; }
0,"public void testAvailable() { byte[] byteArray0 = new byte[3]; Base32 base32_0 = new Base32(); ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0); base32_0.encodeToString(byteArray0); BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false); baseNCodecInputStream0.available(); }",public int available() { return this.available; }
0,public void testSize() { new ByteArrayOutputStream(); },public int size() { return this.size; }
0,"public void testGetPlatform() { ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry(); ZipArchiveEntry zipArchiveEntry1 = new ZipArchiveEntry(""y""); zipArchiveEntry1.equals(zipArchiveEntry0); }",public int getPlatform() { return platform; }
0,public void testGetValue() { X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix(); x7875_NewUnix0.getCentralDirectoryLength(); },public int getValue() { return this.value; }
0,"public void testReadEscape() { CSVFormat cSVFormat0 = CSVFormat.DEFAULT; StringReader stringReader0 = new StringReader(""QU,rs$@LR&/""); ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0); CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0); cSVLexer0.readEscape(); cSVLexer0.readEscape(); }","int readEscape() throws IOException { // the escape char has just been read (normally a backslash) final int c = in.read(); switch (c) { case 'r': return CR; case 'n': return LF; case 't': return TAB; case 'b': return BACKSPACE; case 'f': return FF; case CR: case LF: case FF: // TODO is this correct? case TAB: // TODO is this correct? Do tabs need to be escaped? case BACKSPACE: // TODO is this correct? return c; case END_OF_STREAM: throw new IOException(""EOF whilst processing escape sequence""); default: // Now check for meta-characters return c; // indicate unexpected char - available from in.getLastChar() } }"
0,"public void testReadEscape() { StringReader stringReader0 = new StringReader(""org.apache.commons.csv.CSVLexer""); Character character0 = new Character('\''); Quote quote0 = Quote.ALL; Character character1 = new Character('a'); String[] stringArray0 = new String[1]; CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, character1, character0, false, true, ""org.apache.commons.csv.CSVLexer"", (String) null, stringArray0); ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0); CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0); cSVLexer0.readEscape(); cSVLexer0.readEscape(); }","int readEscape() throws IOException { // the escape char has just been read (normally a backslash) final int c = in.read(); switch (c) { case 'r': return CR; case 'n': return LF; case 't': return TAB; case 'b': return BACKSPACE; case 'f': return FF; case CR: case LF: case FF: // TODO is this correct? case TAB: // TODO is this correct? Do tabs need to be escaped? case BACKSPACE: // TODO is this correct? return c; case END_OF_STREAM: throw new IOException(""EOF whilst processing escape sequence""); default: // Now check for meta-characters return c; // indicate unexpected char - available from in.getLastChar() } }"
0,"public void testGetDelimiter() { CSVFormat cSVFormat0 = CSVFormat.DEFAULT; CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""""); cSVFormat1.hashCode(); }",public char getDelimiter() { return delimiter; }
0,public void testGetAllowMissingColumnNames() { CSVFormat cSVFormat0 = CSVFormat.EXCEL; cSVFormat0.withRecordSeparator('q'); },public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; }
0,"public void testGetIgnoreEmptyLines() { CSVFormat cSVFormat0 = CSVFormat.EXCEL; String[] stringArray0 = new String[3]; stringArray0[1] = ""The header contains a duplicate entry: '""; stringArray0[2] = ""c[0TyZhMn}#&:L""; CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0); cSVFormat1.format(stringArray0); }",public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; }
0,"public void testGetAllowMissingColumnNames() { CSVFormat cSVFormat0 = CSVFormat.EXCEL; String[] stringArray0 = new String[3]; stringArray0[1] = ""The header contains a duplicate entry: '""; stringArray0[2] = ""c[0TyZhMn}#&:L""; CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0); cSVFormat1.toString(); }",public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; }
0,"public void testGetIgnoreSurroundingSpaces() { CSVFormat cSVFormat0 = CSVFormat.EXCEL; CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The comment start and the escape character cannot be the same ('""); cSVFormat1.equals(cSVFormat0); }",public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; }
0,public void testGetDelimiter() { CSVFormat cSVFormat0 = CSVFormat.EXCEL; CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('y'); cSVFormat0.equals(cSVFormat1); },public char getDelimiter() { return delimiter; }
0,public void testGetNullString() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; cSVFormat0.withIgnoreEmptyLines(); },public String getNullString() { return nullString; }
0,public void testGetRecordSeparator() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; QuoteMode quoteMode0 = QuoteMode.MINIMAL; CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0); cSVFormat1.hashCode(); },public String getRecordSeparator() { return recordSeparator; }
0,public void testToString() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; String[] stringArray0 = new String[0]; CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0); cSVFormat1.toString(); },"public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); }"
0,public void testGetSkipHeaderRecord() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('$'); cSVFormat0.equals(cSVFormat1); },public boolean getSkipHeaderRecord() { return skipHeaderRecord; }
0,public void testGetDelimiter() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; String[] stringArray0 = new String[0]; CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0); cSVFormat1.getHeader(); },public char getDelimiter() { return delimiter; }
0,public void testGetAllowMissingColumnNames() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; Character character0 = Character.valueOf('8'); CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0); CSVFormat cSVFormat2 = cSVFormat1.withEscape('?'); cSVFormat1.equals(cSVFormat2); },public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; }
0,public void testGetEscapeCharacter() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; CSVFormat cSVFormat1 = cSVFormat0.withQuote('c'); cSVFormat0.equals(cSVFormat1); },public Character getEscapeCharacter() { return escapeCharacter; }
0,public void testGetNullString() { CSVFormat cSVFormat0 = CSVFormat.MYSQL; Character character0 = Character.valueOf('8'); CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0); cSVFormat1.equals(cSVFormat0); },public String getNullString() { return nullString; }
0,public void testGetCurrentSegment() { BufferRecycler bufferRecycler0 = new BufferRecycler(); TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0); textBuffer0.getCurrentSegment(); },"public char[] getCurrentSegment() { /* Since the intention of the caller is to directly add stuff into * buffers, we should NOT have anything in shared buffer... ie. may * need to unshare contents. */ if (_inputStart >= 0) { unshare(1); } else { char[] curr = _currentSegment; if (curr == null) { _currentSegment = buf(0); } else if (_currentSize >= curr.length) { // Plus, we better have room for at least one more char expand(1); } } return _currentSegment; }"
0,public void testCreateChildObjectContext() { DupDetector dupDetector0 = DupDetector.rootDetector((JsonParser) null); JsonWriteContext jsonWriteContext0 = JsonWriteContext.createRootContext(dupDetector0); jsonWriteContext0.createChildObjectContext(); },"public JsonWriteContext createChildObjectContext() { JsonWriteContext ctxt = _child; if (ctxt == null) { _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this, (_dups == null) ? null : _dups.child()); return ctxt; } return ctxt.reset(TYPE_OBJECT); }"
0,public void testSize() { BufferRecycler bufferRecycler0 = new BufferRecycler(); TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0); textBuffer0.resetWithEmpty(); },public int size() { if (_inputStart >= 0) { // shared copy from input buf return _inputLen; } if (_resultArray != null) { return _resultArray.length; } if (_resultString != null) { return _resultString.length(); } // local segmented buffers return _segmentSize + _currentSize; }
0,"public void testGetMatchCount() { TokenFilter tokenFilter0 = new TokenFilter(); BufferRecycler bufferRecycler0 = new BufferRecycler(); IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true); StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$""); CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot(); ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0); FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true); filteringParserDelegate0._nextToken2(); filteringParserDelegate0.isExpectedStartArrayToken(); }",public int getMatchCount() { return _matchCount; }
0,"public void testGetMatchCount() { TokenFilter tokenFilter0 = new TokenFilter(); BufferRecycler bufferRecycler0 = new BufferRecycler(); IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true); StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$""); CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot(); ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0); FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true); filteringParserDelegate0._nextToken2(); filteringParserDelegate0.hasTokenId(33); }",public int getMatchCount() { return _matchCount; }
0,"public void testGetMatchCount() { TokenFilter tokenFilter0 = new TokenFilter(); BufferRecycler bufferRecycler0 = new BufferRecycler(); IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, false); StringReader stringReader0 = new StringReader(""[1D.Y`lbK6$""); CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot(); ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0); FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true); FilteringParserDelegate filteringParserDelegate1 = new FilteringParserDelegate(filteringParserDelegate0, tokenFilter0, false, false); filteringParserDelegate0.nextToken(); filteringParserDelegate1.nextValue(); }",public int getMatchCount() { return _matchCount; }
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.class; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); Class<String> class2 = String.class; FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 1006); MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>(); Class<Error> class3 = Error.class; StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class3); mapDeserializer0.withResolved(stdKeyDeserializer_StringKD0, (TypeDeserializer) null, mapDeserializer0, linkedHashSet0); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.class; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); Class<MapperFeature> class2 = MapperFeature.class; CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class2, 10); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, coreXMLDeserializers_Std0, (TypeDeserializer) null); HashSet<String> hashSet0 = new HashSet<String>(); TypeFactory typeFactory0 = TypeFactory.defaultInstance(); ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0); Class<InputStream> class3 = InputStream.class; AsWrapperTypeDeserializer asWrapperTypeDeserializer0 = new AsWrapperTypeDeserializer(collectionLikeType0, classNameIdResolver0, """", false, class3); mapDeserializer0.withResolved((KeyDeserializer) null, asWrapperTypeDeserializer0, coreXMLDeserializers_Std0, hashSet0); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class0, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 3980); MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); mapDeserializer0.getContentType(); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testGetValueType() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.TYPE; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); mapDeserializer0.getValueType(); }",@Override public JavaType getValueType() { return _mapType; }
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.TYPE; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); new MapDeserializer(mapDeserializer0); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, simpleType0); Class<Integer> class1 = Integer.class; StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class1); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, stdKeyDeserializer0, (JsonDeserializer<Object>) null, (TypeDeserializer) null); mapDeserializer0.isCachable(); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.class; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); Class<Error> class2 = Error.class; StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9); MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null); mapDeserializer0.isCachable(); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.class; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); Class<Error> class2 = Error.class; StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9); MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null); BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance; DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0); mapDeserializer0.resolve(defaultDeserializationContext_Impl0); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.TYPE; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); String[] stringArray0 = new String[0]; mapDeserializer0.setIgnorableProperties(stringArray0); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testIsCachable() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.TYPE; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); mapDeserializer0.setIgnorableProperties((String[]) null); }","public boolean isCachable() { /* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }"
0,"public void testWithResolved() { Class<FilterInputStream> class0 = FilterInputStream.class; SimpleType simpleType0 = SimpleType.constructUnsafe(class0); Class<Integer> class1 = Integer.TYPE; CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0); StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0); FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6); MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null); HashSet<String> hashSet0 = new HashSet<String>(); MapDeserializer mapDeserializer1 = mapDeserializer0.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0); mapDeserializer1.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0); }","protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { return this; } return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); }"
0,public void testIsLenient() { StdDateFormat stdDateFormat0 = StdDateFormat.instance; stdDateFormat0.isLenient(); },"public boolean isLenient() { if (_lenient == null) { // default is, I believe, true return true; } return _lenient.booleanValue(); }"
0,public void testGenerateId() { ObjectIdGenerators.IntSequenceGenerator objectIdGenerators_IntSequenceGenerator0 = new ObjectIdGenerators.IntSequenceGenerator(); WritableObjectId writableObjectId0 = new WritableObjectId(objectIdGenerators_IntSequenceGenerator0); writableObjectId0.generateId(objectIdGenerators_IntSequenceGenerator0); Object object0 = new Object(); writableObjectId0.generateId(object0); },"public Object generateId(Object forPojo) { // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of // id being generated for ""alwaysAsId"", but not being written as POJO; regardless, // need to use existing id if there is one: id = generator.generateId(forPojo); return id; }"
0,"public void testToString() { SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT; ReferenceType referenceType0 = new ReferenceType(simpleType0, simpleType0); referenceType0.toString(); }","public String toString() { return new StringBuilder(40) .append(""[reference type, class "") .append(buildCanonicalName()) .append('<') .append(_referencedType) .append('>') .append(']') .toString(); }"
0,"public void testFind() { Class<Void> class0 = Void.class; JdkDeserializers.find(class0, ""com.fasterxml.jackson.databind.JavaType""); }","public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { if (_classNames.contains(clsName)) { JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType); if (d != null) { return d; } if (rawType == UUID.class) { return new UUIDDeserializer(); } if (rawType == StackTraceElement.class) { return new StackTraceElementDeserializer(); } if (rawType == AtomicBoolean.class) { // (note: AtomicInteger/Long work due to single-arg constructor. For now? return new AtomicBooleanDeserializer(); } if (rawType == ByteBuffer.class) { return new ByteBufferDeserializer(); } } return null; }"
0,"public void testEscape() { Charset charset0 = Charset.defaultCharset(); CharsetEncoder charsetEncoder0 = charset0.newEncoder(); Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.extended; String string0 = Entities.escape(""Fo%^]N={*!BXG'NZQ"", charsetEncoder0, entities_EscapeMode0); }","static String escape(String string, Document.OutputSettings out) { return escape(string, out.encoder(), out.escapeMode()); }"
0,"public void testUnescape() { String string0 = Entities.unescape(""Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ""); }","static String unescape(String string) { if (!string.contains(""&"")) return string; Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);? StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } // skip } else { String name = m.group(1).toLowerCase(); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { // out of range String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); // replace with original string } } m.appendTail(accum); return accum.toString(); }"
0,"public void testNodeName() { DocumentType documentType0 = new DocumentType(""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5"", ""/:u'$8-DkwD}/:5""); documentType0.outerHtml(); }","public String nodeName() { return ""#doctype""; }"
0,"public void testIsSafeAttribute() { Whitelist whitelist0 = Whitelist.basicWithImages(); String[] stringArray0 = new String[3]; stringArray0[0] = ""cite""; stringArray0[1] = ""h5WK''""; stringArray0[2] = ""h5WK''""; Whitelist whitelist1 = whitelist0.addAttributes(""cite"", stringArray0); Document document0 = new Document(""h5WK''""); Attribute attribute0 = Attribute.createFromEncoded(""cite"", ""http:h5wk''""); whitelist1.isSafeAttribute(""cite"", document0, attribute0); }","boolean isSafeAttribute(String tagName, Element el, Attribute attr) { TagName tag = TagName.valueOf(tagName); AttributeKey key = AttributeKey.valueOf(attr.getKey()); if (attributes.containsKey(tag)) { if (attributes.get(tag).contains(key)) { if (protocols.containsKey(tag)) { Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); // ok if not defined protocol; otherwise test return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); } else { // attribute found, no protocols defined, so OK return true; } } } else { // no attributes defined for tag, try :all tag return !tagName.equals("":all"") && isSafeAttribute("":all"", el, attr); } return false; }"
0,"public void testIsValid() { Whitelist whitelist0 = new Whitelist(); Cleaner cleaner0 = new Cleaner(whitelist0); Document document0 = Document.createShell(""org.jsoup.safeG Cleae$IlanrngVisitor""); whitelist0.addEnforcedAttribute(""body"", ""<html>\n <head></head>\n <body></body>\n</html>"", ""org.jsoup.safeG Cleae$IlanrngVisitor""); Document document1 = cleaner0.clean(document0); cleaner0.isValid(document1); }","public boolean isValid(Document dirtyDocument) { Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; }"
0,"public void testEquals() { Document document0 = new Document(""value""); Document document1 = new Document("">5Z""); document0.equals(document1); }",public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; return this == o; }
0,"public void testNodeName() { XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""t4N7&Q"", ""NW91EkPm "", false); xmlDeclaration0.toString(); }","public String nodeName() { return ""#declaration""; }"
0,"public void testGetWholeDeclaration() { XmlDeclaration xmlDeclaration0 = new XmlDeclaration(""n/(:P!,Rl&n<F63$O"", ""n/(:P!,Rl&n<F63$O"", false); xmlDeclaration0.getWholeDeclaration(); }","public String getWholeDeclaration() { final String decl = this.name; if(decl.equals(""xml"") && attributes.size() > 1 ) { StringBuilder sb = new StringBuilder(decl); final String version = attributes.get(""version""); if( version != null ) { sb.append("" version=\"""").append(version).append(""\""""); } final String encoding = attributes.get(""encoding""); if( encoding != null ) { sb.append("" encoding=\"""").append(encoding).append(""\""""); } return sb.toString(); } else { return this.name; } }"
0,"public void testNodeName() { XmlDeclaration xmlDeclaration0 = new XmlDeclaration("""", """", true); xmlDeclaration0.toString(); }","public String nodeName() { return ""#declaration""; }"
0,"public void testPos() { new CharacterReader(""<A)s.2T#T`V""); }",public int pos() { return readerPos + bufPos; }
0,"public void testGetValue() { Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null); Attribute attribute1 = attribute0.clone(); attribute1.equals(attribute0); }",public String getValue() { return val; }
0,"public void testGetValue() { Attribute attribute0 = new Attribute(""7b([!ve"", (String) null); attribute0.hashCode(); }",public String getValue() { return val; }
0,"public void testEquals() { Attribute attribute0 = new Attribute(""RG5hzl9})]EB&"", ""RG5hzl9})]EB&""); Attribute attribute1 = new Attribute(""RG5hzl9})]EB&"", (String) null); attribute1.equals(attribute0); }",public boolean equals(Object o) { // note parent not considered if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Attribute attribute = (Attribute) o; if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; return val != null ? val.equals(attribute.val) : attribute.val == null; }
0,"public void testEquals() { Attribute attribute0 = new Attribute(""\""s:O<.p~\n~In\""ka,"", (String) null); attribute0.equals(attribute0); }",public boolean equals(Object o) { // note parent not considered if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Attribute attribute = (Attribute) o; if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; return val != null ? val.equals(attribute.val) : attribute.val == null; }
0,"public void testComputeValue() { Constant constant0 = new Constant(""9|""); CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual0 = new CoreOperationGreaterThanOrEqual(constant0, constant0); CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual1 = new CoreOperationGreaterThanOrEqual(coreOperationGreaterThanOrEqual0, constant0); coreOperationGreaterThanOrEqual1.computeValue((EvalContext) null); }","public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1] .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; }"
0,"public void testTestNode() { HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl(); Locale locale0 = Locale.FRENCH; HTMLTableElementImpl hTMLTableElementImpl0 = new HTMLTableElementImpl(hTMLDocumentImpl0, ""Unknown namespace prefix: ""); DOMNodePointer dOMNodePointer0 = new DOMNodePointer(hTMLTableElementImpl0, locale0); QName qName0 = dOMNodePointer0.getName(); NodeNameTest nodeNameTest0 = new NodeNameTest(qName0, ""http://www.w3.org/XML/1998/namespace""); dOMNodePointer0.testNode((NodeTest) nodeNameTest0); }","public boolean testNode(NodeTest node) { return testNode(node, test); }"
0,"public void testTestNode() { QName qName0 = new QName(""[QT~sGq>_#hT|#8m"", ""[QT~sGq>_#hT|#8m""); VariablePointer variablePointer0 = new VariablePointer(qName0); NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1); JDOMNodePointer.testNode((NodePointer) variablePointer0, (Object) null, (NodeTest) nodeTypeTest0); }","public boolean testNode(NodeTest test) { return testNode(this, node, test); }"
0,"public void testAsPath() { HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl(); DOMNodePointer dOMNodePointer0 = new DOMNodePointer((NodePointer) null, hTMLDocumentImpl0); PSVIDocumentImpl pSVIDocumentImpl0 = new PSVIDocumentImpl(); Element element0 = pSVIDocumentImpl0.createElementNS("""", ""Factory could not create a child node for path: "", ""xmlns""); DOMNodePointer dOMNodePointer1 = new DOMNodePointer(dOMNodePointer0, element0); dOMNodePointer1.asPath(); }","public String asPath() { if (id != null) { return ""id('"" + escape(id) + ""')""; } StringBuffer buffer = new StringBuffer(); if (parent != null) { buffer.append(parent.asPath()); } switch (node.getNodeType()) { case Node.ELEMENT_NODE : // If the parent pointer is not a DOMNodePointer, it is // the parent's responsibility to produce the node test part // of the path if (parent instanceof DOMNodePointer) { if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { buffer.append('/'); } String ln = DOMNodePointer.getLocalName(node); String nsURI = getNamespaceURI(); if (nsURI == null) { buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByQName()).append(']'); } else { String prefix = getNamespaceResolver().getPrefix(nsURI); if (prefix != null) { buffer.append(prefix); buffer.append(':'); buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByQName()); buffer.append(']'); } else { buffer.append(""node()""); buffer.append('['); buffer.append(getRelativePositionOfElement()); buffer.append(']'); } } } break; case Node.TEXT_NODE : case Node.CDATA_SECTION_NODE : buffer.append(""/text()""); buffer.append('['); buffer.append(getRelativePositionOfTextNode()).append(']'); break; case Node.PROCESSING_INSTRUCTION_NODE : buffer.append(""/processing-instruction(\'""); buffer.append(((ProcessingInstruction) node).getTarget()).append(""')""); buffer.append('['); buffer.append(getRelativePositionOfPI()).append(']'); break; case Node.DOCUMENT_NODE : // That'll be empty break; default: break; } return buffer.toString(); }"
0,"public void testToPattern() { ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""*3-""); HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>(); ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(""*3-"", hashMap0); extendedMessageFormat0.equals(extendedMessageFormat1); }",public String toPattern() { return toPattern; }
0,"public void testGetShortClassName() { String string0 = ClassUtils.getShortClassName(""[LJNM-;""); }","public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortClassName(object.getClass()); }"
0,"public void testGetShortCanonicalName() { ClassUtils.getShortCanonicalName(""[""); }","public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); }"
0,"public void testGetShortClassName() { ClassUtils.getShortClassName(""[[LJNM-""); }","public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortClassName(object.getClass()); }"
0,"public void testGetShortCanonicalName() { ClassUtils.getShortCanonicalName(""B""); }","public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); }"
0,"public void testEscapeJava() { StringEscapeUtils.escapeJava(""OZw9N)RwzH/""); }","public static String escapeJava(String str) { return escapeJavaStyleString(str, false); }"
0,"public void testGetDenominator() { Fraction fraction0 = Fraction.getFraction(0, 394); fraction0.reduce(); }",public int getDenominator() { return denominator; }
0,"public void testEscapeJava() { String string0 = ""<<\\u+ob%jNBH/""; StringEscapeUtils.escapeJava(string0); }","public static String escapeJava(String str) { return escapeJavaStyleString(str, false); }"
0,"public void testEscapeJava() { StringEscapeUtils.escapeJava(""3b#H/LYs'XYVNA3|'T""); }","public static String escapeJava(String str) { return escapeJavaStyleString(str, false); }"
0,"public void testGetDenominatorDegreesOfFreedom() { FDistributionImpl fDistributionImpl0 = new FDistributionImpl(763.683107623722, 1225.931330739); fDistributionImpl0.setDenominatorDegreesOfFreedom(1.0); fDistributionImpl0.getInitialDomain((-942.0)); }",public double getDenominatorDegreesOfFreedom() { return denominatorDegreesOfFreedom; }
